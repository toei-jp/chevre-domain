<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"service_task.js.html":{"id":"service_task.js.html","title":"Source: service/task.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service/task.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * タスクサービス */ const createDebug = require(&quot;debug&quot;); const factory = require(&quot;../factory&quot;); const debug = createDebug('chevre-domain:service'); exports.ABORT_REPORT_SUBJECT = 'Task aborted !!!'; /** * execute a task by taskName * タスク名でタスクをひとつ実行する * @param taskName タスク名 */ function executeByName(taskName) { return (settings) =&gt; __awaiter(this, void 0, void 0, function* () { // 未実行のタスクを取得 let task = null; try { task = yield settings.taskRepo.executeOneByName(taskName); debug('task found', task); } catch (error) { debug('executeByName error:', error); } // タスクがなければ終了 if (task !== null) { yield execute(task)(settings); } }); } exports.executeByName = executeByName; /** * execute a task * タスクを実行する * @param task タスクオブジェクト */ function execute(task) { debug('executing a task...', task); const now = new Date(); return (settings) =&gt; __awaiter(this, void 0, void 0, function* () { try { // タスク名の関数が定義されていなければ、TypeErrorとなる const { call } = yield Promise.resolve().then(() =&gt; require(`./task/${task.name}`)); yield call(task.data)(settings); const result = { executedAt: now, error: '' }; yield settings.taskRepo.pushExecutionResultById(task.id, factory.taskStatus.Executed, result); } catch (error) { // 実行結果追加 const result = { executedAt: now, error: error.stack }; // 失敗してもここではステータスを戻さない(Runningのまま待機) yield settings.taskRepo.pushExecutionResultById(task.id, task.status, result); } }); } exports.execute = execute; /** * retry tasks in running status * 実行中ステータスのままになっているタスクをリトライする * @param intervalInMinutes 最終トライ日時から何分経過したタスクをリトライするか */ function retry(intervalInMinutes) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { yield repos.task.retry(intervalInMinutes); }); } exports.retry = retry; /** * abort a task * トライ可能回数が0に達したタスクを実行中止する * @param intervalInMinutes 最終トライ日時から何分経過したタスクを中止するか */ function abort(intervalInMinutes) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const abortedTask = yield repos.task.abortOne(intervalInMinutes); debug('abortedTask found', abortedTask); // 開発者へ報告 const lastResult = (abortedTask.executionResults.length &gt; 0) ? abortedTask.executionResults[abortedTask.executionResults.length - 1].error : // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ ''; debug('reporting...', lastResult); // await NotificationService.report2developers( // ABORT_REPORT_SUBJECT, // `id:${abortedTask.id} // name:${abortedTask.name} // runsAt:${moment(abortedTask.runsAt).toISOString()} // lastTriedAt:${moment(&lt;Date&gt;abortedTask.lastTriedAt).toISOString()} // numberOfTried:${abortedTask.numberOfTried} // lastResult:${lastResult}` // )(); }); } exports.abort = abort; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repository.js.html":{"id":"repository.js.html","title":"Source: repository.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repository.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); // tslint:disable:max-classes-per-file completed-docs /** * リポジトリー */ const action_1 = require(&quot;./repo/action&quot;); const screeningEvent_1 = require(&quot;./repo/aggregation/screeningEvent&quot;); const boxOfficeType_1 = require(&quot;./repo/boxOfficeType&quot;); const creativeWork_1 = require(&quot;./repo/creativeWork&quot;); const distributions_1 = require(&quot;./repo/distributions&quot;); const event_1 = require(&quot;./repo/event&quot;); const screeningEvent_2 = require(&quot;./repo/itemAvailability/screeningEvent&quot;); const place_1 = require(&quot;./repo/place&quot;); const priceSpecification_1 = require(&quot;./repo/priceSpecification&quot;); const reservation_1 = require(&quot;./repo/reservation&quot;); const reservationNumber_1 = require(&quot;./repo/reservationNumber&quot;); const subject_1 = require(&quot;./repo/subject&quot;); const task_1 = require(&quot;./repo/task&quot;); const ticketType_1 = require(&quot;./repo/ticketType&quot;); const transaction_1 = require(&quot;./repo/transaction&quot;); class Action extends action_1.MongoRepository { } exports.Action = Action; class CreativeWork extends creativeWork_1.MongoRepository { } exports.CreativeWork = CreativeWork; class Distributions extends distributions_1.MongoRepository { } exports.Distributions = Distributions; class BoxOfficeType extends boxOfficeType_1.MongoRepository { } exports.BoxOfficeType = BoxOfficeType; class Event extends event_1.MongoRepository { } exports.Event = Event; class Place extends place_1.MongoRepository { } exports.Place = Place; class PriceSpecification extends priceSpecification_1.MongoRepository { } exports.PriceSpecification = PriceSpecification; class Reservation extends reservation_1.MongoRepository { } exports.Reservation = Reservation; class ReservationNumber extends reservationNumber_1.RedisRepository { } exports.ReservationNumber = ReservationNumber; class Subject extends subject_1.MongoRepository { } exports.Subject = Subject; class Task extends task_1.MongoRepository { } exports.Task = Task; class TicketType extends ticketType_1.MongoRepository { } exports.TicketType = TicketType; class Transaction extends transaction_1.MongoRepository { } exports.Transaction = Transaction; var aggregation; (function (aggregation) { class ScreeningEvent extends screeningEvent_1.RedisRepository { } aggregation.ScreeningEvent = ScreeningEvent; })(aggregation = exports.aggregation || (exports.aggregation = {})); var itemAvailability; (function (itemAvailability) { class ScreeningEvent extends screeningEvent_2.RedisRepository { } itemAvailability.ScreeningEvent = ScreeningEvent; })(itemAvailability = exports.itemAvailability || (exports.itemAvailability = {})); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"service_aggregation.js.html":{"id":"service_aggregation.js.html","title":"Source: service/aggregation.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service/aggregation.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * 集計サービス */ const createDebug = require(&quot;debug&quot;); const factory = require(&quot;../factory&quot;); const debug = createDebug('chevre-domain:service'); /** * 上映イベントデータを期間指定で集計する */ // export function aggregateScreeningEvents(params: { // startFrom: Date; // startThrough: Date; // ttl: number; // }): IAggregateScreeningEventOperation&lt;void&gt; { // return async (repos: { // aggregation: ScreeningEventAggregationRepo; // screeningEventAvailability: ScreeningEventAvailabilityRepo; // event: EventRepo; // place: PlaceRepo; // }) =&gt; { // // 集計対象イベント検索 // const events = await repos.event.searchScreeningEvents({ // startFrom: params.startFrom, // startThrough: params.startThrough // }); // // イベントの座席情報検索 // const movieTheatersWithoutScreeningRoom = await repos.place.searchMovieTheaters({}); // const movieTheaters = await Promise.all(movieTheatersWithoutScreeningRoom.map(async (m) =&gt; { // return repos.place.findMovieTheaterByBranchCode(m.branchCode); // })); // // 収容人数を集計 // const aggregations: IScreeningEventAggregation[] = await Promise.all(events.map(async (e) =&gt; { // let maximumAttendeeCapacity: number = 0; // let remainingAttendeeCapacity: number = 0; // const movieTheater = movieTheaters.find((m) =&gt; m.branchCode === e.superEvent.location.branchCode); // if (movieTheater === undefined) { // // 基本的にありえないはずだが、万が一劇場が見つからなければcapacityは0のまま // console.error(new Error('Movie theater not found')); // } else { // const screeningRoom = &lt;factory.place.movieTheater.IScreeningRoom | undefined&gt; // movieTheater.containsPlace.find((p) =&gt; p.branchCode === e.location.branchCode); // if (screeningRoom === undefined) { // // 基本的にありえないはずだが、万が一スクリーンが見つからなければcapacityは0のまま // console.error(new Error('Screening room not found')); // } else { // maximumAttendeeCapacity = screeningRoom.containsPlace.reduce((a, b) =&gt; a + b.containsPlace.length, 0); // const unavailableOffers = await repos.screeningEventAvailability.findUnavailableOffersByEventId({ eventId: e.id }); // remainingAttendeeCapacity = maximumAttendeeCapacity - unavailableOffers.length; // } // } // return { // id: e.id, // maximumAttendeeCapacity: maximumAttendeeCapacity, // remainingAttendeeCapacity: remainingAttendeeCapacity // }; // })); // // 保管 // await repos.aggregation.store(aggregations, params.ttl); // }; // } /** * 上映イベントデータをID指定で集計する */ function aggregateScreeningEvent(params) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { // 集計対象イベント検索 const event = yield repos.event.findById(params); // 全予約検索 const limit = 100; let page = 0; let numData = limit; const confirmedReservations = []; while (numData === limit) { page += 1; const reservations = yield repos.reservation.searchScreeningEventReservations({ limit: limit, page: page, reservationFor: { typeOf: factory.eventType.ScreeningEvent, id: event.id }, reservationStatuses: [factory.reservationStatusType.ReservationConfirmed] }); numData = reservations.length; debug('numData:', numData); confirmedReservations.push(...reservations); } // イベントの座席情報検索 const movieTheatersWithoutScreeningRoom = yield repos.place.searchMovieTheaters({}); const movieTheaters = yield Promise.all(movieTheatersWithoutScreeningRoom.map((m) =&gt; __awaiter(this, void 0, void 0, function* () { return repos.place.findMovieTheaterByBranchCode(m.branchCode); }))); // 収容人数を集計 let maximumAttendeeCapacity = 0; let remainingAttendeeCapacity = 0; let checkInCount = 0; let attendeeCount = 0; const movieTheater = movieTheaters.find((m) =&gt; m.branchCode === event.superEvent.location.branchCode); if (movieTheater === undefined) { // 基本的にありえないはずだが、万が一劇場が見つからなければcapacityは0のまま console.error(new Error('Movie theater not found')); } else { const screeningRoom = movieTheater.containsPlace.find((p) =&gt; p.branchCode === event.location.branchCode); if (screeningRoom === undefined) { // 基本的にありえないはずだが、万が一スクリーンが見つからなければcapacityは0のまま console.error(new Error('Screening room not found')); } else { maximumAttendeeCapacity = screeningRoom.containsPlace.reduce((a, b) =&gt; a + b.containsPlace.length, 0); remainingAttendeeCapacity = maximumAttendeeCapacity - confirmedReservations.length; checkInCount = confirmedReservations.filter((r) =&gt; r.checkedIn).length; attendeeCount = confirmedReservations.filter((r) =&gt; r.attended).length; } } const aggregation = { maximumAttendeeCapacity: maximumAttendeeCapacity, remainingAttendeeCapacity: remainingAttendeeCapacity, checkInCount: checkInCount, attendeeCount: attendeeCount }; debug('aggregation:', aggregation); // 保管 yield repos.event.eventModel.findOneAndUpdate({ typeOf: factory.eventType.ScreeningEvent, _id: event.id }, aggregation, { new: true }).exec(); }); } exports.aggregateScreeningEvent = aggregateScreeningEvent; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"service.js.html":{"id":"service.js.html","title":"Source: service.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * service module */ const AggregationService = require(&quot;./service/aggregation&quot;); const EventService = require(&quot;./service/event&quot;); const OfferService = require(&quot;./service/offer&quot;); const TaskService = require(&quot;./service/task&quot;); const CancelReservationTransactionService = require(&quot;./service/transaction/cancelReservation&quot;); const ReserveTransactionService = require(&quot;./service/transaction/reserve&quot;); exports.aggregation = AggregationService; exports.event = EventService; exports.offer = OfferService; exports.task = TaskService; var transaction; (function (transaction) { transaction.cancelReservation = CancelReservationTransactionService; transaction.reserve = ReserveTransactionService; })(transaction = exports.transaction || (exports.transaction = {})); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"service_task_reserve.js.html":{"id":"service_task_reserve.js.html","title":"Source: service/task/reserve.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service/task/reserve.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const action_1 = require(&quot;../../repo/action&quot;); const reservation_1 = require(&quot;../../repo/reservation&quot;); const task_1 = require(&quot;../../repo/task&quot;); const ReserveService = require(&quot;../reserve&quot;); /** * タスク実行関数 */ function call(data) { return (settings) =&gt; __awaiter(this, void 0, void 0, function* () { const actionRepo = new action_1.MongoRepository(settings.connection); const reservationRepo = new reservation_1.MongoRepository(settings.connection); const taskRepo = new task_1.MongoRepository(settings.connection); yield ReserveService.confirmReservation(data.actionAttributes)({ action: actionRepo, reservation: reservationRepo, task: taskRepo }); }); } exports.call = call; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"service_task_aggregateScreeningEvent.js.html":{"id":"service_task_aggregateScreeningEvent.js.html","title":"Source: service/task/aggregateScreeningEvent.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service/task/aggregateScreeningEvent.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const event_1 = require(&quot;../../repo/event&quot;); const place_1 = require(&quot;../../repo/place&quot;); const reservation_1 = require(&quot;../../repo/reservation&quot;); const AggregationService = require(&quot;../aggregation&quot;); /** * タスク実行関数 */ function call(data) { return (settings) =&gt; __awaiter(this, void 0, void 0, function* () { const eventRepo = new event_1.MongoRepository(settings.connection); const placeRepo = new place_1.MongoRepository(settings.connection); const reservationRepo = new reservation_1.MongoRepository(settings.connection); yield AggregationService.aggregateScreeningEvent(data)({ event: eventRepo, place: placeRepo, reservation: reservationRepo }); }); } exports.call = call; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"service_task_cancelReservation.js.html":{"id":"service_task_cancelReservation.js.html","title":"Source: service/task/cancelReservation.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service/task/cancelReservation.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;../../factory&quot;); const action_1 = require(&quot;../../repo/action&quot;); const screeningEvent_1 = require(&quot;../../repo/itemAvailability/screeningEvent&quot;); const reservation_1 = require(&quot;../../repo/reservation&quot;); const task_1 = require(&quot;../../repo/task&quot;); const transaction_1 = require(&quot;../../repo/transaction&quot;); const ReserveService = require(&quot;../reserve&quot;); /** * タスク実行関数 */ function call(data) { return (settings) =&gt; __awaiter(this, void 0, void 0, function* () { if (settings.redisClient === undefined) { throw new factory.errors.Argument('settings', 'redisClient required'); } const actionRepo = new action_1.MongoRepository(settings.connection); const reservationRepo = new reservation_1.MongoRepository(settings.connection); const taskRepo = new task_1.MongoRepository(settings.connection); const transactionRepo = new transaction_1.MongoRepository(settings.connection); const eventAvailabilityRepo = new screeningEvent_1.RedisRepository(settings.redisClient); yield ReserveService.cancelReservation(data.actionAttributes)({ action: actionRepo, reservation: reservationRepo, task: taskRepo, transaction: transactionRepo, eventAvailability: eventAvailabilityRepo }); }); } exports.call = call; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"service_task_cancelPendingReservation.js.html":{"id":"service_task_cancelPendingReservation.js.html","title":"Source: service/task/cancelPendingReservation.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service/task/cancelPendingReservation.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;../../factory&quot;); const action_1 = require(&quot;../../repo/action&quot;); const screeningEvent_1 = require(&quot;../../repo/itemAvailability/screeningEvent&quot;); const reservation_1 = require(&quot;../../repo/reservation&quot;); const transaction_1 = require(&quot;../../repo/transaction&quot;); const ReserveService = require(&quot;../reserve&quot;); /** * タスク実行関数 */ function call(data) { return (settings) =&gt; __awaiter(this, void 0, void 0, function* () { if (settings.redisClient === undefined) { throw new factory.errors.Argument('settings', 'redisClient required'); } const actionRepo = new action_1.MongoRepository(settings.connection); const reservationRepo = new reservation_1.MongoRepository(settings.connection); const transactionRepo = new transaction_1.MongoRepository(settings.connection); const eventAvailabilityRepo = new screeningEvent_1.RedisRepository(settings.redisClient); yield ReserveService.cancelPendingReservation(data.actionAttributes)({ action: actionRepo, reservation: reservationRepo, transaction: transactionRepo, eventAvailability: eventAvailabilityRepo }); }); } exports.call = call; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"service_transaction_reserve.js.html":{"id":"service_transaction_reserve.js.html","title":"Source: service/transaction/reserve.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service/transaction/reserve.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * 予約取引サービス */ const createDebug = require(&quot;debug&quot;); const factory = require(&quot;../../factory&quot;); const OfferService = require(&quot;../offer&quot;); const ReserveService = require(&quot;../reserve&quot;); const debug = createDebug('chevre-domain:service'); /** * 取引開始 */ // tslint:disable-next-line:max-func-body-length function start(params) { // tslint:disable-next-line:max-func-body-length return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { debug('starting transaction...', params); const now = new Date(); // イベント存在確認 const screeningEvent = yield repos.event.findById({ typeOf: factory.eventType.ScreeningEvent, id: params.object.event.id }); // チケット存在確認 const ticketOffers = yield OfferService.searchScreeningEventTicketOffers({ eventId: params.object.event.id })(repos); const ticketTypes = yield repos.ticketType.findByTicketGroupId({ ticketGroupId: screeningEvent.ticketTypeGroup }); debug('available ticket type:', ticketTypes); // 予約番号発行 const reservationNumber = yield repos.reservationNumber.publish({ reserveDate: now, sellerBranchCode: screeningEvent.superEvent.location.branchCode }); // 取引ファクトリーで新しい進行中取引オブジェクトを作成 const tickets = params.object.acceptedOffer.map((offer) =&gt; { const ticketOffer = ticketOffers.find((t) =&gt; t.id === offer.id); if (ticketOffer === undefined) { throw new factory.errors.NotFound('Ticket Offer'); } const totalPrice = ticketOffer.priceSpecification.priceComponent.reduce((a, b) =&gt; a + b.price, 0); let ticketType = ticketTypes.find((t) =&gt; t.id === offer.id); if (ticketType === undefined) { ticketType = { id: ticketOffer.id, name: ticketOffer.name, description: ticketOffer.description, notes: { ja: '', en: '' }, price: totalPrice, availability: factory.itemAvailability.InStock, isOnlineTicket: true, typeOfNote: 0, isBoxTicket: true, nameForManagementSite: '', nameForPrinting: '', seatReservationUnit: 1, subject: '', nonBoxOfficeSubject: '', indicatorColor: '' }; } return { typeOf: 'Ticket', dateIssued: now, issuedBy: { typeOf: screeningEvent.location.typeOf, name: screeningEvent.location.name.ja }, totalPrice: totalPrice, priceCurrency: factory.priceCurrency.JPY, ticketedSeat: offer.ticketedSeat, underName: { typeOf: params.agent.typeOf, name: params.agent.name }, ticketType: ticketType }; }); // 仮予約作成 const reservations = yield Promise.all(tickets.map((ticket, index) =&gt; __awaiter(this, void 0, void 0, function* () { return createReservation({ id: `${reservationNumber}-${index}`, reserveDate: now, agent: params.agent, reservationNumber: reservationNumber, screeningEvent: screeningEvent, reservedTicket: ticket }); }))); const startParams = { typeOf: factory.transactionType.Reserve, agent: params.agent, object: { clientUser: params.object.clientUser, event: screeningEvent, reservations: reservations, notes: params.object.notes }, expires: params.expires }; // 取引作成 let transaction; try { transaction = yield repos.transaction.start(startParams); } catch (error) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ if (error.name === 'MongoError') { // no op } throw error; } // 座席ロック yield repos.eventAvailability.lock({ eventId: screeningEvent.id, offers: tickets.map((ticket) =&gt; { return { seatSection: ticket.ticketedSeat.seatSection, seatNumber: ticket.ticketedSeat.seatNumber }; }), expires: screeningEvent.endDate, holder: transaction.id }); // 予約作成 yield Promise.all(reservations.map((r) =&gt; __awaiter(this, void 0, void 0, function* () { yield repos.reservation.reservationModel.create(Object.assign({}, r, { _id: r.id })); }))); return transaction; }); } exports.start = start; function createReservation(params) { return { typeOf: factory.reservationType.EventReservation, id: params.id, additionalTicketText: params.reservedTicket.ticketType.name.ja, modifiedTime: params.reserveDate, numSeats: 1, price: params.reservedTicket.totalPrice, priceCurrency: factory.priceCurrency.JPY, reservationFor: params.screeningEvent, reservationNumber: params.reservationNumber, reservationStatus: factory.reservationStatusType.ReservationPending, reservedTicket: params.reservedTicket, underName: params.agent, checkedIn: false, attended: false }; } /** * 取引確定 */ function confirm(params) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { debug(`confirming reserve transaction ${params.transactionId}...`); // 取引存在確認 const transaction = yield repos.transaction.findById({ typeOf: factory.transactionType.Reserve, id: params.transactionId }); // 予約アクション属性作成 const reserveActionAttributes = transaction.object.reservations.map((r) =&gt; { if (params.issuedBy !== undefined) { r.reservedTicket.issuedBy = params.issuedBy; } // 予約者の指定があれば上書き if (params.underName !== undefined) { r.underName = params.underName; r.reservedTicket.underName = params.underName; } return { typeOf: factory.actionType.ReserveAction, description: transaction.object.notes, result: {}, object: r, agent: transaction.agent, purpose: { typeOf: transaction.typeOf, id: transaction.id } }; }); const potentialActions = { reserve: reserveActionAttributes }; // 取引確定 const result = {}; yield repos.transaction.confirm({ typeOf: factory.transactionType.Reserve, id: transaction.id, result: result, potentialActions: potentialActions }); }); } exports.confirm = confirm; /** * 取引中止 */ function cancel(params) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { // まず取引状態変更 const transaction = yield repos.transaction.cancel({ typeOf: factory.transactionType.Reserve, id: params.transactionId }); // 本来非同期でタスクが実行されるが、同期的に仮予約取消が実行されていないと、サービス利用側が困る可能性があるので、 // 一応同期的にもcancelPendingReservationを実行しておく try { const actionAttributes = transaction.object.reservations.map((r) =&gt; { return { typeOf: factory.actionType.CancelAction, purpose: { typeOf: transaction.typeOf, id: transaction.id }, agent: transaction.agent, object: r }; }); yield ReserveService.cancelPendingReservation(actionAttributes)(repos); } catch (error) { // no op } }); } exports.cancel = cancel; /** * ひとつの取引のタスクをエクスポートする */ function exportTasks(status) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const transaction = yield repos.transaction.startExportTasks({ typeOf: factory.transactionType.Reserve, status: status }); if (transaction === null) { return; } // 失敗してもここでは戻さない(RUNNINGのまま待機) yield exportTasksById(transaction.id)(repos); yield repos.transaction.setTasksExportedById({ id: transaction.id }); }); } exports.exportTasks = exportTasks; /** * ID指定で取引のタスク出力 */ function exportTasksById(transactionId) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const transaction = yield repos.transaction.findById({ typeOf: factory.transactionType.Reserve, id: transactionId }); const potentialActions = transaction.potentialActions; const taskAttributes = []; switch (transaction.status) { case factory.transactionStatusType.Confirmed: // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (potentialActions !== undefined) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (potentialActions.reserve !== undefined) { const reserveTask = { name: factory.taskName.Reserve, status: factory.taskStatus.Ready, runsAt: new Date(), remainingNumberOfTries: 10, lastTriedAt: null, numberOfTried: 0, executionResults: [], data: { actionAttributes: potentialActions.reserve } }; taskAttributes.push(reserveTask); } } break; case factory.transactionStatusType.Canceled: case factory.transactionStatusType.Expired: const actionAttributes = transaction.object.reservations.map((r) =&gt; { return { typeOf: factory.actionType.CancelAction, purpose: { typeOf: transaction.typeOf, id: transaction.id }, agent: transaction.agent, object: r }; }); const cancelPendingReservationTask = { name: factory.taskName.CancelPendingReservation, status: factory.taskStatus.Ready, runsAt: new Date(), remainingNumberOfTries: 10, lastTriedAt: null, numberOfTried: 0, executionResults: [], data: { actionAttributes: actionAttributes } }; taskAttributes.push(cancelPendingReservationTask); break; default: throw new factory.errors.NotImplemented(`Transaction status &quot;${transaction.status}&quot; not implemented.`); } debug('taskAttributes prepared', taskAttributes); return Promise.all(taskAttributes.map((a) =&gt; __awaiter(this, void 0, void 0, function* () { return repos.task.save(a); }))); }); } exports.exportTasksById = exportTasksById; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"service_reserve.js.html":{"id":"service_reserve.js.html","title":"Source: service/reserve.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service/reserve.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * 予約サービス */ const createDebug = require(&quot;debug&quot;); const factory = require(&quot;../factory&quot;); const debug = createDebug('chevre-domain:service'); /** * 予約を確定する */ function confirmReservation(actionAttributesList) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { yield Promise.all(actionAttributesList.map((actionAttributes) =&gt; __awaiter(this, void 0, void 0, function* () { // アクション開始 const action = yield repos.action.start(actionAttributes); try { // 予約を確定状態に変更する yield repos.reservation.confirm(actionAttributes.object); } catch (error) { // actionにエラー結果を追加 try { const actionError = Object.assign({}, error, { message: error.message, name: error.name }); yield repos.action.giveUp({ typeOf: action.typeOf, id: action.id, error: actionError }); } catch (__) { // 失敗したら仕方ない } throw error; } // アクション完了 const actionResult = {}; yield repos.action.complete({ typeOf: action.typeOf, id: action.id, result: actionResult }); }))); const aggregateTask = { name: factory.taskName.AggregateScreeningEvent, status: factory.taskStatus.Ready, runsAt: new Date(), remainingNumberOfTries: 10, lastTriedAt: null, numberOfTried: 0, executionResults: [], data: actionAttributesList[0].object.reservationFor }; yield repos.task.save(aggregateTask); }); } exports.confirmReservation = confirmReservation; /** * 進行中の予約をキャンセルする */ function cancelPendingReservation(actionAttributesList) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const reserveTransaction = yield repos.transaction.findById({ typeOf: factory.transactionType.Reserve, id: actionAttributesList[0].purpose.id }); debug('canceling reservations...', actionAttributesList); yield Promise.all(actionAttributesList.map((actionAttributes) =&gt; __awaiter(this, void 0, void 0, function* () { // アクション開始 const action = yield repos.action.start(actionAttributes); try { // 予約をキャンセル状態に変更する const reservation = actionAttributes.object; yield repos.reservation.cancel({ id: reservation.id }); // 予約取引がまだ座席を保持していれば座席ロック解除 const lockKey = { eventId: reservation.reservationFor.id, offer: { seatNumber: reservation.reservedTicket.ticketedSeat.seatNumber, seatSection: reservation.reservedTicket.ticketedSeat.seatSection } }; const holder = yield repos.eventAvailability.getHolder(lockKey); if (holder === reserveTransaction.id) { yield repos.eventAvailability.unlock(lockKey); } } catch (error) { // actionにエラー結果を追加 try { const actionError = Object.assign({}, error, { message: error.message, name: error.name }); yield repos.action.giveUp({ typeOf: action.typeOf, id: action.id, error: actionError }); } catch (__) { // 失敗したら仕方ない } throw error; } // アクション完了 const actionResult = {}; yield repos.action.complete({ typeOf: action.typeOf, id: action.id, result: actionResult }); }))); }); } exports.cancelPendingReservation = cancelPendingReservation; /** * 予約をキャンセルする */ function cancelReservation(actionAttributesList) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const cancelReservationTransaction = yield repos.transaction.findById({ typeOf: factory.transactionType.CancelReservation, id: actionAttributesList[0].purpose.id }); debug('canceling reservations...', actionAttributesList); yield Promise.all(actionAttributesList.map((actionAttributes) =&gt; __awaiter(this, void 0, void 0, function* () { // アクション開始 const action = yield repos.action.start(actionAttributes); try { // 予約をキャンセル状態に変更する const reservation = actionAttributes.object; yield repos.reservation.cancel({ id: reservation.id }); // 予約取引がまだ座席を保持していれば座席ロック解除 const lockKey = { eventId: reservation.reservationFor.id, offer: { seatNumber: reservation.reservedTicket.ticketedSeat.seatNumber, seatSection: reservation.reservedTicket.ticketedSeat.seatSection } }; const holder = yield repos.eventAvailability.getHolder(lockKey); if (holder === cancelReservationTransaction.object.transaction.id) { yield repos.eventAvailability.unlock(lockKey); } } catch (error) { // actionにエラー結果を追加 try { const actionError = Object.assign({}, error, { message: error.message, name: error.name }); yield repos.action.giveUp({ typeOf: action.typeOf, id: action.id, error: actionError }); } catch (__) { // 失敗したら仕方ない } throw error; } // アクション完了 const actionResult = {}; yield repos.action.complete({ typeOf: action.typeOf, id: action.id, result: actionResult }); }))); const aggregateTask = { name: factory.taskName.AggregateScreeningEvent, status: factory.taskStatus.Ready, runsAt: new Date(), remainingNumberOfTries: 10, lastTriedAt: null, numberOfTried: 0, executionResults: [], data: actionAttributesList[0].object.reservationFor }; yield repos.task.save(aggregateTask); }); } exports.cancelReservation = cancelReservation; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"service_transaction_cancelReservation.js.html":{"id":"service_transaction_cancelReservation.js.html","title":"Source: service/transaction/cancelReservation.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service/transaction/cancelReservation.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * 予約キャンセル取引サービス */ const createDebug = require(&quot;debug&quot;); const factory = require(&quot;../../factory&quot;); const debug = createDebug('chevre-domain:service'); /** * 取引開始 */ function start(params) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { debug('starting transaction...', params); // 予約取引存在確認 const reserveTransaction = yield repos.transaction.findById({ typeOf: factory.transactionType.Reserve, id: params.object.transaction.id }); const startParams = { typeOf: factory.transactionType.CancelReservation, agent: params.agent, object: { clientUser: params.object.clientUser, transaction: reserveTransaction }, expires: params.expires }; // 取引作成 let transaction; try { transaction = yield repos.transaction.start(startParams); } catch (error) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ if (error.name === 'MongoError') { // no op } throw error; } // tslint:disable-next-line:no-suspicious-comment // TODO 予約ホールド // await Promise.all(reservations.map(async (r) =&gt; { // await repos.reservation.reservationModel.create({ ...r, _id: r.id }); // })); return transaction; }); } exports.start = start; /** * 取引確定 */ function confirm(params) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { debug(`confirming reserve transaction ${params.transactionId}...`); // 取引存在確認 const transaction = yield repos.transaction.findById({ typeOf: factory.transactionType.CancelReservation, id: params.transactionId }); const reserveTransaction = transaction.object.transaction; // 予約アクション属性作成 const cancelReservationActionAttributes = reserveTransaction.object.reservations.map((r) =&gt; { return { typeOf: factory.actionType.CancelAction, // description: transaction.object.notes, result: {}, object: r, agent: transaction.agent, purpose: { typeOf: transaction.typeOf, id: transaction.id } }; }); const potentialActions = { cancelReservation: cancelReservationActionAttributes }; // 取引確定 const result = {}; yield repos.transaction.confirm({ typeOf: factory.transactionType.CancelReservation, id: transaction.id, result: result, potentialActions: potentialActions }); }); } exports.confirm = confirm; /** * ひとつの取引のタスクをエクスポートする */ function exportTasks(status) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const transaction = yield repos.transaction.startExportTasks({ typeOf: factory.transactionType.CancelReservation, status: status }); if (transaction === null) { return; } // 失敗してもここでは戻さない(RUNNINGのまま待機) yield exportTasksById(transaction.id)(repos); yield repos.transaction.setTasksExportedById({ id: transaction.id }); }); } exports.exportTasks = exportTasks; /** * ID指定で取引のタスク出力 */ function exportTasksById(transactionId) { return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const transaction = yield repos.transaction.findById({ typeOf: factory.transactionType.CancelReservation, id: transactionId }); const potentialActions = transaction.potentialActions; const taskAttributes = []; switch (transaction.status) { case factory.transactionStatusType.Confirmed: // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (potentialActions !== undefined) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (potentialActions.cancelReservation !== undefined) { const cancelReservationTask = { name: factory.taskName.CancelReservation, status: factory.taskStatus.Ready, runsAt: new Date(), remainingNumberOfTries: 10, lastTriedAt: null, numberOfTried: 0, executionResults: [], data: { actionAttributes: potentialActions.cancelReservation } }; taskAttributes.push(cancelReservationTask); } } break; case factory.transactionStatusType.Canceled: case factory.transactionStatusType.Expired: // const cancelMoneyTransferTask: factory.task.cancelMoneyTransfer.IAttributes = { // name: factory.taskName.CancelMoneyTransfer, // status: factory.taskStatus.Ready, // runsAt: new Date(), // なるはやで実行 // remainingNumberOfTries: 10, // lastTriedAt: null, // numberOfTried: 0, // executionResults: [], // data: { // transaction: { typeOf: transaction.typeOf, id: transaction.id } // } // }; // taskAttributes.push(cancelMoneyTransferTask); break; default: throw new factory.errors.NotImplemented(`Transaction status &quot;${transaction.status}&quot; not implemented.`); } debug('taskAttributes prepared', taskAttributes); return Promise.all(taskAttributes.map((a) =&gt; __awaiter(this, void 0, void 0, function* () { return repos.task.save(a); }))); }); } exports.exportTasksById = exportTasksById; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"service_event.js.html":{"id":"service_event.js.html","title":"Source: service/event.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service/event.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * countTicketTypePerEvent */ function countTicketTypePerEvent(params) { // tslint:disable-next-line:max-func-body-length return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const reservations = yield repos.reservation.searchScreeningEventReservations({ reservationFor: { superEvent: params.id !== undefined ? { id: params.id } : undefined, startFrom: params.startFrom, startThrough: params.startThrough } }); const SALE_TICKET_TYPE = 1; const PRE_SALE_TICKET_TYPE = 2; const FREE_TICKET_TYPE = 3; let events = []; reservations.forEach((r) =&gt; { if (events.find((e) =&gt; e.id === r.reservationFor.id) === undefined) { events.push(Object.assign({}, r.reservationFor, { freeTicketCount: 0, saleTicketCount: 0, preSaleTicketCount: 0 })); } for (const event of events) { if (event.id === r.reservationFor.id) { switch (r.reservedTicket.ticketType.typeOfNote) { case SALE_TICKET_TYPE: event.saleTicketCount += 1; break; case PRE_SALE_TICKET_TYPE: event.preSaleTicketCount += 1; break; case FREE_TICKET_TYPE: event.freeTicketCount += 1; break; default: // 何もしない } } } }); events = events.sort((a, b) =&gt; (a.startDate &lt; b.startDate ? -1 : 1)); return { totalCount: events.length, data: events.slice(params.limit * (params.page - 1), params.limit * params.page) }; }); } exports.countTicketTypePerEvent = countTicketTypePerEvent; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_schemaTypes_multilingualString.js.html":{"id":"repo_mongoose_schemaTypes_multilingualString.js.html","title":"Source: repo/mongoose/schemaTypes/multilingualString.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/schemaTypes/multilingualString.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * 多言語文字列mongooseスキーマタイプ */ exports.default = { en: { type: String, required: false }, ja: { type: String, required: false }, kr: { type: String, required: false } }; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: index.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * index module */ const mongoose = require(&quot;mongoose&quot;); const redis = require(&quot;redis&quot;); const factory = require(&quot;./factory&quot;); const repository = require(&quot;./repository&quot;); const service = require(&quot;./service&quot;); /** * MongoDBクライアント`mongoose` * @example * const promise = domain.mongoose.connect('mongodb://localhost/myapp', { * useMongoClient: true * }); */ exports.mongoose = mongoose; /** * Redis Cacheクライアント * @example * const client = domain.redis.createClient({ * host: process.env.REDIS_HOST, * port: process.env.REDIS_PORT, * password: process.env.REDIS_KEY, * tls: { servername: process.env.REDIS_HOST } * }); */ exports.redis = redis; exports.factory = factory; exports.repository = repository; exports.service = service; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_creativeWork.js.html":{"id":"repo_creativeWork.js.html","title":"Source: repo/creativeWork.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/creativeWork.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const creativeWork_1 = require(&quot;./mongoose/model/creativeWork&quot;); const factory = require(&quot;../factory&quot;); /** * 作品抽象リポジトリー */ class Repository { } exports.Repository = Repository; /** * 作品リポジトリー */ class MongoRepository { constructor(connection) { this.creativeWorkModel = connection.model(creativeWork_1.default.modelName); } static CREATE_MONGO_CONDITIONS(params) { // MongoDB検索条件 const andConditions = [ { typeOf: factory.creativeWorkType.Movie } ]; if (params.identifier !== undefined) { andConditions.push({ identifier: new RegExp(params.identifier, 'i') }); } if (params.name !== undefined) { andConditions.push({ name: new RegExp(params.name, 'i') }); } if (params.datePublishedFrom !== undefined) { andConditions.push({ datePublished: { $gte: params.datePublishedFrom } }); } if (params.datePublishedTo !== undefined) { andConditions.push({ datePublished: { $lte: params.datePublishedTo } }); } if (params.checkScheduleEndDate !== undefined) { andConditions.push({ $or: [ { scheduleEndDate: { $gt: new Date() } }, { scheduleEndDate: null } ] }); } return andConditions; } /** * 映画作品を保管する */ saveMovie(movie) { return __awaiter(this, void 0, void 0, function* () { yield this.creativeWorkModel.findOneAndUpdate({ identifier: movie.identifier, typeOf: factory.creativeWorkType.Movie }, movie, { upsert: true }).exec(); }); } /** * IDで映画作品を検索する */ findMovieByIdentifier(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.creativeWorkModel.findOne({ typeOf: factory.creativeWorkType.Movie, identifier: params.identifier }, { __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (doc === null) { throw new factory.errors.NotFound('Movie'); } return doc.toObject(); }); } countMovies(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MONGO_CONDITIONS(params); return this.creativeWorkModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } /** * 映画作品を検索する */ searchMovies(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MONGO_CONDITIONS(params); const query = this.creativeWorkModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0 }); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.sort !== undefined) { query.sort(params.sort); } return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * 映画作品を削除する */ deleteMovie(params) { return __awaiter(this, void 0, void 0, function* () { yield this.creativeWorkModel.findOneAndRemove({ identifier: params.identifier, typeOf: factory.creativeWorkType.Movie }).exec(); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_event.js.html":{"id":"repo_event.js.html","title":"Source: repo/event.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/event.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const uniqid = require(&quot;uniqid&quot;); const factory = require(&quot;../factory&quot;); const event_1 = require(&quot;./mongoose/model/event&quot;); /** * イベントリポジトリー */ class MongoRepository { constructor(connection) { this.eventModel = connection.model(event_1.default.modelName); } // tslint:disable-next-line:max-func-body-length static CREATE_SCREENING_EVENT_MONGO_CONDITIONS(params) { const andConditions = [ { typeOf: factory.eventType.ScreeningEvent } ]; // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.name !== undefined) { andConditions.push({ $or: [ { 'name.ja': new RegExp(params.name, 'i') }, { 'name.en': new RegExp(params.name, 'i') } ] }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.superEvent !== undefined) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(params.superEvent.ids)) { andConditions.push({ 'superEvent.id': { $exists: true, $in: params.superEvent.ids } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(params.superEvent.locationBranchCodes)) { andConditions.push({ 'superEvent.location.branchCode': { $exists: true, $in: params.superEvent.locationBranchCodes } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(params.superEvent.workPerformedIdentifiers)) { andConditions.push({ 'superEvent.workPerformed.identifier': { $exists: true, $in: params.superEvent.workPerformedIdentifiers } }); } } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(params.eventStatuses)) { andConditions.push({ eventStatus: { $in: params.eventStatuses } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.inSessionFrom !== undefined) { andConditions.push({ endDate: { $gt: params.inSessionFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.inSessionThrough !== undefined) { andConditions.push({ startDate: { $lt: params.inSessionThrough } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.startFrom !== undefined) { andConditions.push({ startDate: { $gte: params.startFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.startThrough !== undefined) { andConditions.push({ startDate: { $lt: params.startThrough } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.endFrom !== undefined) { andConditions.push({ endDate: { $gte: params.endFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.endThrough !== undefined) { andConditions.push({ endDate: { $lt: params.endThrough } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.offers !== undefined) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.offers.availableFrom instanceof Date) { andConditions.push({ 'offers.availabilityEnds': { $exists: true, $gt: params.offers.availableFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.offers.availableThrough instanceof Date) { andConditions.push({ 'offers.availabilityStarts': { $exists: true, $lt: params.offers.availableThrough } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.offers.validFrom instanceof Date) { andConditions.push({ 'offers.validThrough': { $exists: true, $gt: params.offers.validFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.offers.validThrough instanceof Date) { andConditions.push({ 'offers.validFrom': { $exists: true, $lt: params.offers.validThrough } }); } } return andConditions; } static CREATE_SCREENING_EVENT_SERIES_MONGO_CONDITIONS(params) { const andConditions = [ { typeOf: factory.eventType.ScreeningEventSeries } ]; // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.name !== undefined) { andConditions.push({ $or: [ { 'name.ja': new RegExp(params.name, 'i') }, { 'name.en': new RegExp(params.name, 'i') }, { kanaName: new RegExp(params.name, 'i') } ] }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.location !== undefined) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(params.location.branchCodes)) { andConditions.push({ 'location.branchCode': { $exists: true, $in: params.location.branchCodes } }); } } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(params.eventStatuses)) { andConditions.push({ eventStatus: { $in: params.eventStatuses } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.workPerformed !== undefined) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(params.workPerformed.identifiers)) { andConditions.push({ 'workPerformed.identifier': { $in: params.workPerformed.identifiers } }); } } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.inSessionFrom !== undefined) { andConditions.push({ endDate: { $gt: params.inSessionFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.inSessionThrough !== undefined) { andConditions.push({ startDate: { $lt: params.inSessionThrough } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.startFrom !== undefined) { andConditions.push({ startDate: { $gte: params.startFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.startThrough !== undefined) { andConditions.push({ startDate: { $lt: params.startThrough } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.endFrom !== undefined) { andConditions.push({ endDate: { $gte: params.endFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.endThrough !== undefined) { andConditions.push({ endDate: { $lt: params.endThrough } }); } return andConditions; } /** * 上映イベントを保管する */ saveScreeningEventSeries(params) { return __awaiter(this, void 0, void 0, function* () { let event; if (params.id === undefined) { const id = uniqid(); const doc = yield this.eventModel.create(Object.assign({}, params.attributes, { _id: id })); event = doc.toObject(); } else { const doc = yield this.eventModel.findOneAndUpdate({ _id: params.id, typeOf: factory.eventType.ScreeningEventSeries }, params.attributes, { upsert: false, new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('Event'); } event = doc.toObject(); } return event; }); } /** * 上映イベントを保管する */ saveScreeningEvent(params) { return __awaiter(this, void 0, void 0, function* () { let event; if (params.id === undefined) { const id = uniqid(); const doc = yield this.eventModel.create(Object.assign({}, params.attributes, { _id: id })); event = doc.toObject(); } else { const doc = yield this.eventModel.findOneAndUpdate({ _id: params.id, typeOf: factory.eventType.ScreeningEvent }, params.attributes, { upsert: false, new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('Event'); } event = doc.toObject(); } return event; }); } /** * 複数の上映イベントを保管する */ saveMultipleScreeningEvent(params) { return __awaiter(this, void 0, void 0, function* () { const args = params.map((p) =&gt; (Object.assign({ _id: uniqid() }, p))); const docs = yield this.eventModel.create(args); return docs.map((doc) =&gt; doc.toObject()); }); } countScreeningEvents(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_SCREENING_EVENT_MONGO_CONDITIONS(params); return this.eventModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } /** * 上映イベントを検索する */ searchScreeningEvents(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_SCREENING_EVENT_MONGO_CONDITIONS(params); const query = this.eventModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0 }); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.sort !== undefined) { query.sort(params.sort); } return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } countScreeningEventSeries(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_SCREENING_EVENT_SERIES_MONGO_CONDITIONS(params); return this.eventModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } /** * 上映イベントシリーズを検索する */ searchScreeningEventSeries(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_SCREENING_EVENT_SERIES_MONGO_CONDITIONS(params); const query = this.eventModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0 }); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.sort !== undefined) { query.sort(params.sort); } return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * IDでイベントを取得する */ findById(params) { return __awaiter(this, void 0, void 0, function* () { const event = yield this.eventModel.findOne({ typeOf: params.typeOf, _id: params.id }, { __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (event === null) { throw new factory.errors.NotFound('Event'); } return event.toObject(); }); } /** * IDでイベントを削除する */ deleteById(params) { return __awaiter(this, void 0, void 0, function* () { yield this.eventModel.findOneAndRemove({ typeOf: params.typeOf, _id: params.id }).exec(); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_distributions.js.html":{"id":"repo_distributions.js.html","title":"Source: repo/distributions.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/distributions.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const distributions_1 = require(&quot;./mongoose/model/distributions&quot;); const factory = require(&quot;../factory&quot;); /** * 配給レポジトリー */ class MongoRepository { constructor(connection) { this.distributionsModel = connection.model(distributions_1.default.modelName); } static CREATE_MONGO_CONDITIONS(params) { // MongoDB検索条件 const andConditions = []; // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.name !== undefined) { andConditions.push({ name: new RegExp(params.name, 'i') }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.id !== undefined) { andConditions.push({ _id: params.id }); } return andConditions; } /** * 配給を保管する */ updateDistribution(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.distributionsModel.findOneAndUpdate({ _id: params.id }, { name: params.name }, { upsert: false, new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('Distribution'); } return doc.toObject(); }); } /** * 配給を作成する */ createDistribution(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.distributionsModel.create({ _id: params.id, name: params.name }); return doc.toObject(); }); } getDistributions() { return __awaiter(this, void 0, void 0, function* () { const query = this.distributionsModel.find({}); return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } countDistributions(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MONGO_CONDITIONS(params); return this.distributionsModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } /** * 配給を検索する */ searchDistributions(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MONGO_CONDITIONS(params); const query = this.distributionsModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0 }); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * IDで配給を取得する */ findById(params) { return __awaiter(this, void 0, void 0, function* () { const event = yield this.distributionsModel.findOne({ _id: params.id }, { __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (event === null) { throw new factory.errors.NotFound('Distribution'); } return event.toObject(); }); } /** * IDで配給を削除する */ deleteById(params) { return __awaiter(this, void 0, void 0, function* () { yield this.distributionsModel.findOneAndRemove({ _id: params.id }).exec(); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_transaction.js.html":{"id":"repo_transaction.js.html","title":"Source: repo/transaction.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/transaction.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const moment = require(&quot;moment&quot;); const factory = require(&quot;../factory&quot;); const transaction_1 = require(&quot;./mongoose/model/transaction&quot;); /** * 取引リポジトリー */ class MongoRepository { constructor(connection) { this.transactionModel = connection.model(transaction_1.default.modelName); } // tslint:disable-next-line:cyclomatic-complexity max-func-body-length static CREATE_MONGO_CONDITIONS(params) { const andConditions = [ { typeOf: params.typeOf } ]; // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.startFrom !== undefined) { andConditions.push({ startDate: { $gt: params.startFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.startThrough !== undefined) { andConditions.push({ startDate: { $lt: params.startThrough } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.endFrom !== undefined) { andConditions.push({ endDate: { $exists: true, $gte: params.endFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.endThrough !== undefined) { andConditions.push({ endDate: { $exists: true, $lt: params.endThrough } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(params.ids)) { andConditions.push({ _id: { $in: params.ids } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(params.statuses)) { andConditions.push({ status: { $in: params.statuses } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.agent !== undefined) { if (Array.isArray(params.agent.ids)) { andConditions.push({ 'agent.id': { $in: params.agent.ids } }); } } switch (params.typeOf) { case factory.transactionType.CancelReservation: break; case factory.transactionType.Reserve: break; default: } return andConditions; } /** * 取引を開始する */ start(params) { return __awaiter(this, void 0, void 0, function* () { return this.transactionModel.create(Object.assign({ typeOf: params.typeOf }, params, { status: factory.transactionStatusType.InProgress, startDate: new Date(), endDate: undefined, tasksExportationStatus: factory.transactionTasksExportationStatus.Unexported })).then((doc) =&gt; doc.toObject()); }); } /** * IDで取引を取得する */ findById(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.transactionModel.findOne({ _id: params.id, typeOf: params.typeOf }).exec(); if (doc === null) { throw new factory.errors.NotFound('Transaction'); } return doc.toObject(); }); } /** * 進行中の取引を取得する */ findInProgressById(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.transactionModel.findOne({ _id: params.id, typeOf: params.typeOf, status: factory.transactionStatusType.InProgress }).exec(); if (doc === null) { throw new factory.errors.NotFound('Transaction'); } return doc.toObject(); }); } /** * 取引を確定する */ confirm(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.transactionModel.findOneAndUpdate({ _id: params.id, typeOf: params.typeOf, status: factory.transactionStatusType.InProgress }, { status: factory.transactionStatusType.Confirmed, endDate: new Date(), result: params.result, potentialActions: params.potentialActions // resultを更新 }, { new: true }).exec(); // NotFoundであれば取引状態確認 if (doc === null) { const transaction = yield this.findById({ typeOf: params.typeOf, id: params.id }); if (transaction.status === factory.transactionStatusType.Confirmed) { // すでに確定済の場合 return transaction; } else if (transaction.status === factory.transactionStatusType.Expired) { throw new factory.errors.Argument('Transaction id', 'Transaction already expired'); } else if (transaction.status === factory.transactionStatusType.Canceled) { throw new factory.errors.Argument('Transaction id', 'Transaction already canceled'); } else { throw new factory.errors.NotFound(this.transactionModel.modelName); } } return doc.toObject(); }); } /** * タスク未エクスポートの取引をひとつ取得してエクスポートを開始する */ startExportTasks(params) { return __awaiter(this, void 0, void 0, function* () { return this.transactionModel.findOneAndUpdate({ typeOf: params.typeOf, status: params.status, tasksExportationStatus: factory.transactionTasksExportationStatus.Unexported }, { tasksExportationStatus: factory.transactionTasksExportationStatus.Exporting }, { new: true }).exec().then((doc) =&gt; (doc === null) ? null : doc.toObject()); }); } /** * タスクエクスポートリトライ * todo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ */ reexportTasks(params) { return __awaiter(this, void 0, void 0, function* () { yield this.transactionModel.findOneAndUpdate({ tasksExportationStatus: factory.transactionTasksExportationStatus.Exporting, updatedAt: { $lt: moment().add(-params.intervalInMinutes, 'minutes').toISOString() } }, { tasksExportationStatus: factory.transactionTasksExportationStatus.Unexported }).exec(); }); } /** * set task status exported by transaction id * IDでタスクをエクスポート済に変更する */ setTasksExportedById(params) { return __awaiter(this, void 0, void 0, function* () { yield this.transactionModel.findByIdAndUpdate(params.id, { tasksExportationStatus: factory.transactionTasksExportationStatus.Exported, tasksExportedAt: moment().toDate() }).exec(); }); } /** * 取引を期限切れにする */ makeExpired() { return __awaiter(this, void 0, void 0, function* () { const endDate = moment().toDate(); // ステータスと期限を見て更新 yield this.transactionModel.update({ status: factory.transactionStatusType.InProgress, expires: { $lt: endDate } }, { status: factory.transactionStatusType.Expired, endDate: endDate }, { multi: true }).exec(); }); } /** * 取引を中止する */ cancel(params) { return __awaiter(this, void 0, void 0, function* () { const endDate = moment().toDate(); // 進行中ステータスの取引を中止する const doc = yield this.transactionModel.findOneAndUpdate({ typeOf: params.typeOf, _id: params.id, status: factory.transactionStatusType.InProgress }, { status: factory.transactionStatusType.Canceled, endDate: endDate }, { new: true }).exec(); // NotFoundであれば取引状態確認 if (doc === null) { const transaction = yield this.findById(params); if (transaction.status === factory.transactionStatusType.Canceled) { // すでに中止済の場合 return transaction; } else if (transaction.status === factory.transactionStatusType.Expired) { throw new factory.errors.Argument('Transaction id', 'Transaction already expired'); } else if (transaction.status === factory.transactionStatusType.Confirmed) { throw new factory.errors.Argument('Transaction id', 'Confirmed transaction unable to cancel'); } else { throw new factory.errors.NotFound(this.transactionModel.modelName); } } return doc.toObject(); }); } count(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MONGO_CONDITIONS(params); return this.transactionModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } /** * 取引を検索する */ search(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MONGO_CONDITIONS(params); const query = this.transactionModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0 }); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.sort !== undefined) { query.sort(params.sort); } return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_ticketType.js.html":{"id":"repo_ticketType.js.html","title":"Source: repo/ticketType.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/ticketType.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;../factory&quot;); const ticketType_1 = require(&quot;./mongoose/model/ticketType&quot;); const ticketTypeGroup_1 = require(&quot;./mongoose/model/ticketTypeGroup&quot;); /** * Mongoリポジトリー */ class MongoRepository { constructor(connection) { this.ticketTypeModel = connection.model(ticketType_1.default.modelName); this.ticketTypeGroupModel = connection.model(ticketTypeGroup_1.default.modelName); } static CREATE_TICKET_TYPE_MONGO_CONDITIONS(params) { // MongoDB検索条件 const andConditions = [ { _id: { $exists: true } } ]; if (params.id !== undefined &amp;&amp; params.id !== '') { // andConditions.push({ _id: new RegExp(params.id, 'i') }); if (params.id.length &gt; 0) { andConditions.push({ _id: { $in: params.id } }); } } if (params.name !== undefined) { andConditions.push({ $or: [ { 'name.ja': new RegExp(params.name, 'i') }, { 'name.en': new RegExp(params.name, 'i') } ] }); } if (params.price !== undefined) { andConditions.push({ price: { $lte: params.price } }); } // idHasChoose if (params.idHasChoose !== undefined &amp;&amp; params.idHasChoose !== '') { if (params.idHasChoose.length &gt; 0) { andConditions.push({ _id: { $not: { $in: params.idHasChoose } } }); } } return andConditions; } static CREATE_TICKET_TYPE_GROUP_MONGO_CONDITIONS(params) { // MongoDB検索条件 const andConditions = [ { _id: { $exists: true } } ]; if (params.id !== undefined) { andConditions.push({ _id: new RegExp(params.id, 'i') }); } if (params.name !== undefined) { andConditions.push({ $or: [ { 'name.ja': new RegExp(params.name, 'i') }, { 'name.en': new RegExp(params.name, 'i') } ] }); } return andConditions; } findByTicketGroupId(params) { return __awaiter(this, void 0, void 0, function* () { const ticketTypeGroup = yield this.ticketTypeGroupModel.findById(params.ticketGroupId, { __v: 0, createdAt: 0, updatedAt: 0 }).exec() .then((doc) =&gt; { if (doc === null) { throw new factory.errors.NotFound('Ticket type group'); } return doc.toObject(); }); return this.ticketTypeModel.find({ _id: { $in: ticketTypeGroup.ticketTypes } }).exec() .then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * 券種グループを作成する */ createTicketTypeGroup(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.ticketTypeGroupModel.create(Object.assign({}, params, { _id: params.id })); return doc.toObject(); }); } /** * IDで件券種グループを検索する */ findTicketTypeGroupById(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.ticketTypeGroupModel.findOne({ _id: params.id }, { __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (doc === null) { throw new factory.errors.NotFound('Ticket type group'); } return doc.toObject(); }); } countTicketTypeGroups(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_TICKET_TYPE_GROUP_MONGO_CONDITIONS(params); return this.ticketTypeGroupModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } /** * 券種グループを検索する */ searchTicketTypeGroups(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_TICKET_TYPE_GROUP_MONGO_CONDITIONS(params); const query = this.ticketTypeGroupModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0 }); if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } return query.sort({ _id: 1 }) .setOptions({ maxTimeMS: 10000 }) .exec() .then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * 券種グループを更新する */ updateTicketTypeGroup(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.ticketTypeGroupModel.findOneAndUpdate({ _id: params.id }, params, { upsert: false, new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('Ticket type group'); } }); } /** * 券種グループを削除する */ deleteTicketTypeGroup(params) { return __awaiter(this, void 0, void 0, function* () { yield this.ticketTypeGroupModel.findOneAndRemove({ _id: params.id }).exec(); }); } /** * 券種を作成する */ createTicketType(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.ticketTypeModel.create(Object.assign({}, params, { _id: params.id })); return doc.toObject(); }); } /** * IDで件券種を検索する */ findTicketTypeById(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.ticketTypeModel.findOne({ _id: new RegExp(params.id, 'i') }, { __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (doc === null) { throw new factory.errors.NotFound('Ticket type group'); } return doc.toObject(); }); } countTicketTypes(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_TICKET_TYPE_MONGO_CONDITIONS(params); return this.ticketTypeModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } /** * 券種を検索する */ searchTicketTypes(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_TICKET_TYPE_MONGO_CONDITIONS(params); const query = this.ticketTypeModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0 }); if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } return query.sort({ _id: 1 }) .setOptions({ maxTimeMS: 10000 }) .exec() .then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * 券種を更新する */ updateTicketType(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.ticketTypeModel.findOneAndUpdate({ _id: params.id }, params, { upsert: false, new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('Ticket type'); } }); } /** * 券種を削除する */ deleteTicketType(params) { return __awaiter(this, void 0, void 0, function* () { yield this.ticketTypeModel.findOneAndRemove({ _id: params.id }).exec(); }); } /** * 関連券種グループリスト */ findTicketTypeGroupByTicketTypeId(params) { return __awaiter(this, void 0, void 0, function* () { const query = this.ticketTypeGroupModel.find({ ticketTypes: { $in: [params.ticketTypeId] } }, { __v: 0, createdAt: 0, updatedAt: 0 }); return query.sort({ _id: 1 }) .setOptions({ maxTimeMS: 10000 }) .exec() .then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_task.js.html":{"id":"repo_task.js.html","title":"Source: repo/task.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/task.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const moment = require(&quot;moment&quot;); const task_1 = require(&quot;./mongoose/model/task&quot;); const factory = require(&quot;../factory&quot;); /** * タスク実行時のソート条件 */ const sortOrder4executionOfTasks = { numberOfTried: 1, runsAt: 1 // 実行予定日時の早さ優先 }; /** * タスクレポジトリー */ class MongoRepository { constructor(connection) { this.taskModel = connection.model(task_1.default.modelName); } save(taskAttributes) { return __awaiter(this, void 0, void 0, function* () { return this.taskModel.create(taskAttributes).then((doc) =&gt; doc.toObject()); }); } executeOneByName(taskName) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.taskModel.findOneAndUpdate({ status: factory.taskStatus.Ready, runsAt: { $lt: new Date() }, name: taskName }, { status: factory.taskStatus.Running, lastTriedAt: new Date(), $inc: { remainingNumberOfTries: -1, numberOfTried: 1 // トライ回数増やす } }, { new: true }).sort(sortOrder4executionOfTasks).exec(); if (doc === null) { throw new factory.errors.NotFound('executable task'); } return doc.toObject(); }); } retry(intervalInMinutes) { return __awaiter(this, void 0, void 0, function* () { const lastTriedAtShoudBeLessThan = moment().add(-intervalInMinutes, 'minutes').toDate(); yield this.taskModel.update({ status: factory.taskStatus.Running, lastTriedAt: { $lt: lastTriedAtShoudBeLessThan }, remainingNumberOfTries: { $gt: 0 } }, { status: factory.taskStatus.Ready // 実行前に変更 }, { multi: true }).exec(); }); } abortOne(intervalInMinutes) { return __awaiter(this, void 0, void 0, function* () { const lastTriedAtShoudBeLessThan = moment().add(-intervalInMinutes, 'minutes').toDate(); const doc = yield this.taskModel.findOneAndUpdate({ status: factory.taskStatus.Running, lastTriedAt: { $lt: lastTriedAtShoudBeLessThan }, remainingNumberOfTries: 0 }, { status: factory.taskStatus.Aborted }, { new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('abortable task'); } return doc.toObject(); }); } pushExecutionResultById(id, status, executionResult) { return __awaiter(this, void 0, void 0, function* () { yield this.taskModel.findByIdAndUpdate(id, { status: status, $push: { executionResults: executionResult } }).exec(); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_subject.js.html":{"id":"repo_subject.js.html","title":"Source: repo/subject.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/subject.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const subject_1 = require(&quot;./mongoose/model/subject&quot;); const factory = require(&quot;../factory&quot;); /** * 科目レポジトリー */ class MongoRepository { constructor(connection) { this.subjectModel = connection.model(subject_1.default.modelName); } static CREATE_MONGO_CONDITIONS(params) { // MongoDB検索条件 const andConditions = []; if (params.detailCd !== undefined) { andConditions.push({ detailCd: new RegExp(params.detailCd, 'i') }); } return andConditions; } /** * 科目を保管する */ save(params) { return __awaiter(this, void 0, void 0, function* () { let subject; if (params.id === undefined) { const doc = yield this.subjectModel.create(Object.assign({}, params.attributes)); subject = doc.toObject(); } else { const doc = yield this.subjectModel.findOneAndUpdate({ _id: params.id }, params.attributes, { upsert: false, new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('Subject'); } subject = doc.toObject(); } return subject; }); } countSubject(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MONGO_CONDITIONS(params); return this.subjectModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } /** * IDで科目を検索する */ findSubjectById(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.subjectModel.findOne({ _id: mongoose.Types.ObjectId(params.id) }, { __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (doc === null) { throw new factory.errors.NotFound('Subject'); } return doc.toObject(); }); } /** * 科目を検索する */ searchSubject(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MONGO_CONDITIONS(params); const query = this.subjectModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0 }); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.sort !== undefined) { query.sort(params.sort); } return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } getSubject() { return __awaiter(this, void 0, void 0, function* () { const query = this.subjectModel.find({}); return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_place.js.html":{"id":"repo_place.js.html","title":"Source: repo/place.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/place.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const place_1 = require(&quot;./mongoose/model/place&quot;); const factory = require(&quot;../factory&quot;); /** * 場所抽象リポジトリー */ class Repository { } exports.Repository = Repository; /** * 場所リポジトリー */ class MongoRepository { constructor(connection) { this.placeModel = connection.model(place_1.default.modelName); } static CREATE_MOVIE_THEATER_MONGO_CONDITIONS(params) { // MongoDB検索条件 const andConditions = [ { typeOf: factory.placeType.MovieTheater } ]; // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.name !== undefined) { andConditions.push({ $or: [ { 'name.ja': new RegExp(params.name, 'i') }, { 'name.en': new RegExp(params.name, 'i') }, { kanaName: new RegExp(params.name, 'i') } ] }); } return andConditions; } /** * 劇場を保管する */ saveMovieTheater(movieTheater) { return __awaiter(this, void 0, void 0, function* () { yield this.placeModel.findOneAndUpdate({ typeOf: factory.placeType.MovieTheater, branchCode: movieTheater.branchCode }, movieTheater, { upsert: true }).exec(); }); } countMovieTheaters(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MOVIE_THEATER_MONGO_CONDITIONS(params); return this.placeModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } /** * 劇場検索 */ searchMovieTheaters(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MOVIE_THEATER_MONGO_CONDITIONS(params); // containsPlaceを含めるとデータサイズが大きくなるので、検索結果には含めない const query = this.placeModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0, containsPlace: 0 }); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.sort !== undefined) { query.sort(params.sort); } return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * 枝番号で劇場検索 */ findMovieTheaterByBranchCode(branchCode) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.placeModel.findOne({ typeOf: factory.placeType.MovieTheater, branchCode: branchCode }, { __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (doc === null) { throw new factory.errors.NotFound('movieTheater'); } return doc.toObject(); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_boxOfficeType.js.html":{"id":"repo_boxOfficeType.js.html","title":"Source: repo/boxOfficeType.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/boxOfficeType.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const boxOfficeType_1 = require(&quot;./mongoose/model/boxOfficeType&quot;); const factory = require(&quot;../factory&quot;); /** * 興行区分レポジトリー */ class MongoRepository { constructor(connection) { this.boxOfficeTypeModel = connection.model(boxOfficeType_1.default.modelName); } static CREATE_MONGO_CONDITIONS(params) { // MongoDB検索条件 const andConditions = []; // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.name !== undefined) { andConditions.push({ name: new RegExp(params.name, 'i') }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.id !== undefined) { andConditions.push({ _id: params.id }); } return andConditions; } /** * 興行区分を保管する */ updateBoxOfficeType(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.boxOfficeTypeModel.findOneAndUpdate({ _id: params.id }, { name: params.name }, { upsert: false, new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('BoxOfficeType'); } return doc.toObject(); }); } /** * 興行区分を作成する */ createBoxOfficeType(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.boxOfficeTypeModel.create({ _id: params.id, name: params.name }); return doc.toObject(); }); } getBoxOfficeType() { return __awaiter(this, void 0, void 0, function* () { const query = this.boxOfficeTypeModel.find({}); return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } countBoxOfficeType(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MONGO_CONDITIONS(params); return this.boxOfficeTypeModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } /** * 興行区分を検索する */ searchBoxOfficeType(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_MONGO_CONDITIONS(params); const query = this.boxOfficeTypeModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0 }); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * IDで興行区分を取得する */ findById(params) { return __awaiter(this, void 0, void 0, function* () { const event = yield this.boxOfficeTypeModel.findOne({ _id: params.id }, { __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (event === null) { throw new factory.errors.NotFound('BoxOfficeType'); } return event.toObject(); }); } /** * IDで興行区分を削除する */ deleteById(params) { return __awaiter(this, void 0, void 0, function* () { yield this.boxOfficeTypeModel.findOneAndRemove({ _id: params.id }).exec(); }); } getBoxOfficeTypeList() { return __awaiter(this, void 0, void 0, function* () { const query = this.boxOfficeTypeModel.find({}); return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_reservation.js.html":{"id":"repo_reservation.js.html","title":"Source: repo/reservation.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/reservation.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const reservation_1 = require(&quot;./mongoose/model/reservation&quot;); const factory = require(&quot;../factory&quot;); /** * 予約リポジトリー */ class MongoRepository { constructor(connection) { this.reservationModel = connection.model(reservation_1.default.modelName); } static CREATE_EVENT_RESERVATION_MONGO_CONDITIONS(params) { // MongoDB検索条件 const andConditions = [ { typeOf: factory.reservationType.EventReservation } ]; // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(params.ids)) { andConditions.push({ _id: { $in: params.ids } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (Array.isArray(params.reservationStatuses)) { andConditions.push({ reservationStatus: { $in: params.reservationStatuses } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.modifiedFrom !== undefined) { andConditions.push({ modifiedTime: { $gte: params.modifiedFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.modifiedThrough !== undefined) { andConditions.push({ modifiedTime: { $lte: params.modifiedThrough } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.reservationFor !== undefined) { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.reservationFor.typeOf !== undefined &amp;&amp; params.reservationFor.id !== undefined) { andConditions.push({ 'reservationFor.typeOf': params.reservationFor.typeOf }, { 'reservationFor.id': params.reservationFor.id }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.reservationFor.superEvent !== undefined) { andConditions.push({ 'reservationFor.superEvent.id': params.reservationFor.superEvent.id }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.reservationFor.startFrom !== undefined) { andConditions.push({ 'reservationFor.startDate': { $gte: params.reservationFor.startFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.reservationFor.startThrough !== undefined) { andConditions.push({ 'reservationFor.startDate': { $lte: params.reservationFor.startThrough } }); } } return andConditions; } countScreeningEventReservations(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_EVENT_RESERVATION_MONGO_CONDITIONS(params); return this.reservationModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } /** * 上映イベント予約を検索する */ searchScreeningEventReservations(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_EVENT_RESERVATION_MONGO_CONDITIONS(params); const query = this.reservationModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0 }); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.sort !== undefined) { query.sort(params.sort); } return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } /** * IDで上映イベント予約を検索する */ findScreeningEventReservationById(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.reservationModel.findById(params.id, { __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (doc === null) { throw new factory.errors.NotFound('Reservation'); } return doc.toObject(); }); } /** * 予約確定 */ confirm(params) { return __awaiter(this, void 0, void 0, function* () { yield this.reservationModel.findByIdAndUpdate(params.id, Object.assign({}, params, { reservationStatus: factory.reservationStatusType.ReservationConfirmed, modifiedTime: new Date() })).exec().then((doc) =&gt; { if (doc === null) { throw new factory.errors.NotFound('Reservation'); } }); }); } /** * 予約取消 */ cancel(params) { return __awaiter(this, void 0, void 0, function* () { yield this.reservationModel.findByIdAndUpdate(params.id, { reservationStatus: factory.reservationStatusType.ReservationCancelled, modifiedTime: new Date() }).exec().then((doc) =&gt; { if (doc === null) { throw new factory.errors.NotFound('Reservation'); } }); }); } /** * 発券する */ checkIn(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.reservationModel.findByIdAndUpdate(params.id, { checkedIn: true, modifiedTime: new Date() }, { new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('Reservation'); } return doc.toObject(); }); } /** * 入場する */ attend(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.reservationModel.findByIdAndUpdate(params.id, { attended: true, modifiedTime: new Date() }, { new: true }).exec(); if (doc === null) { throw new factory.errors.NotFound('Reservation'); } return doc.toObject(); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_priceSpecification.js.html":{"id":"repo_priceSpecification.js.html","title":"Source: repo/priceSpecification.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/priceSpecification.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const priceSpecification_1 = require(&quot;./mongoose/model/priceSpecification&quot;); /** * 価格仕様リポジトリー */ class MongoRepository { constructor(connection) { this.priceSpecificationModel = connection.model(priceSpecification_1.default.modelName); } static CREATE_COMPOUND_PRICE_SPECIFICATION_MONGO_CONDITIONS(params) { const andConditions = [ { typeOf: params.typeOf } ]; // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.validFrom !== undefined) { andConditions.push({ validThrough: { $exists: true, $gt: params.validFrom } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.validThrough !== undefined) { andConditions.push({ validFrom: { $exists: true, $lt: params.validThrough } }); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.priceComponent !== undefined) { andConditions.push({ 'priceComponent.typeOf': { $exists: true, $eq: params.priceComponent.typeOf } }); } return andConditions; } countCompoundPriceSpecifications(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_COMPOUND_PRICE_SPECIFICATION_MONGO_CONDITIONS(params); return this.priceSpecificationModel.countDocuments({ $and: conditions }).setOptions({ maxTimeMS: 10000 }) .exec(); }); } searchCompoundPriceSpecifications(params) { return __awaiter(this, void 0, void 0, function* () { const conditions = MongoRepository.CREATE_COMPOUND_PRICE_SPECIFICATION_MONGO_CONDITIONS(params); const query = this.priceSpecificationModel.find({ $and: conditions }, { __v: 0, createdAt: 0, updatedAt: 0 }); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.limit !== undefined &amp;&amp; params.page !== undefined) { query.limit(params.limit).skip(params.limit * (params.page - 1)); } // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else */ if (params.sort !== undefined) { query.sort(params.sort); } return query.setOptions({ maxTimeMS: 10000 }).exec().then((docs) =&gt; docs.map((doc) =&gt; doc.toObject())); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_action.js.html":{"id":"repo_action.js.html","title":"Source: repo/action.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/action.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const factory = require(&quot;../factory&quot;); const action_1 = require(&quot;./mongoose/model/action&quot;); /** * アクションリポジトリー */ class MongoRepository { constructor(connection) { this.actionModel = connection.model(action_1.default.modelName); } /** * アクション開始 */ start(attributes) { return __awaiter(this, void 0, void 0, function* () { return this.actionModel.create(Object.assign({}, attributes, { actionStatus: factory.actionStatusType.ActiveActionStatus, startDate: new Date() })).then((doc) =&gt; doc.toObject()); }); } /** * アクション完了 */ complete(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.actionModel.findOneAndUpdate({ typeOf: params.typeOf, _id: params.id }, { actionStatus: factory.actionStatusType.CompletedActionStatus, result: params.result, endDate: new Date() }, { new: true }).select({ __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (doc === null) { throw new factory.errors.NotFound(this.actionModel.modelName); } return doc.toObject(); }); } /** * アクション取消 */ cancel(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.actionModel.findOneAndUpdate({ typeOf: params.typeOf, _id: params.id }, { actionStatus: factory.actionStatusType.CanceledActionStatus }, { new: true }).select({ __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (doc === null) { throw new factory.errors.NotFound(this.actionModel.modelName); } return doc.toObject(); }); } /** * アクション失敗 */ giveUp(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.actionModel.findOneAndUpdate({ typeOf: params.typeOf, _id: params.id }, { actionStatus: factory.actionStatusType.FailedActionStatus, error: params.error, endDate: new Date() }, { new: true }).select({ __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (doc === null) { throw new factory.errors.NotFound(this.actionModel.modelName); } return doc.toObject(); }); } /** * IDで取得する */ findById(params) { return __awaiter(this, void 0, void 0, function* () { const doc = yield this.actionModel.findOne({ typeOf: params.typeOf, _id: params.id }).select({ __v: 0, createdAt: 0, updatedAt: 0 }).exec(); if (doc === null) { throw new factory.errors.NotFound(this.actionModel.modelName); } return doc.toObject(); }); } } exports.MongoRepository = MongoRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_aggregation_screeningEvent.js.html":{"id":"repo_aggregation_screeningEvent.js.html","title":"Source: repo/aggregation/screeningEvent.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/aggregation/screeningEvent.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); /** * 上映イベントに関する集計データを保管するリポジトリ */ class RedisRepository { constructor(redisClient) { this.redisClient = redisClient; } store(aggregations, ttl) { return __awaiter(this, void 0, void 0, function* () { return new Promise((resolve, reject) =&gt; { const key = RedisRepository.KEY_PREFIX; const filedsAndValues = aggregations.reduce((a, b) =&gt; [...a, b.id, JSON.stringify(b)], []); this.redisClient.multi() .hmset(key, filedsAndValues) .expire(key, ttl) .exec((err) =&gt; { if (err !== null) { reject(err); } else { resolve(); } }); }); }); } // public async findById(id: string): Promise&lt;factory.performance.IPerformanceWithAggregation&gt; { // return new Promise&lt;factory.performance.IPerformanceWithAggregation&gt;((resolve, reject) =&gt; { // const key = RedisRepository.KEY_PREFIX; // this.redisClient.hget(key, id, (err, result) =&gt; { // debug('performance on redis found.', err); // if (err !== null) { // reject(err); // } else { // if (result === null) { // reject(new factory.errors.NotFound('performanceWithAggregation')); // } else { // resolve(JSON.parse(result)); // } // } // }); // }); // } findAll() { return __awaiter(this, void 0, void 0, function* () { return new Promise((resolve, reject) =&gt; { const key = RedisRepository.KEY_PREFIX; this.redisClient.hgetall(key, (err, result) =&gt; { if (err !== null) { reject(err); } else { if (result === null) { resolve({}); } else { resolve(Object.keys(result).reduce((a, b) =&gt; { return Object.assign({}, a, { [b]: JSON.parse(result[b]) }); }, {})); } } }); }); }); } } RedisRepository.KEY_PREFIX = 'chevre:aggregation:screeningEvent'; exports.RedisRepository = RedisRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_itemAvailability_screeningEvent.js.html":{"id":"repo_itemAvailability_screeningEvent.js.html","title":"Source: repo/itemAvailability/screeningEvent.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/itemAvailability/screeningEvent.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const createDebug = require(&quot;debug&quot;); const moment = require(&quot;moment&quot;); const factory = require(&quot;../../factory&quot;); const debug = createDebug('chevre-domain:repo'); /** * 上映イベントに対する座席ごとの在庫状況を保管するリポジトリ */ class RedisRepository { constructor(redisClient) { this.redisClient = redisClient; } /** * 座席をロックする */ lock(lockKey) { return __awaiter(this, void 0, void 0, function* () { debug('locking...', lockKey); const key = `${RedisRepository.KEY_PREFIX}:${lockKey.eventId}`; const value = lockKey.holder; const multi = this.redisClient.multi(); const fields = lockKey.offers.map((offer) =&gt; `${offer.seatSection}:${offer.seatNumber}`); fields.forEach((field) =&gt; { multi.hsetnx(key, field, value); }); const results = yield new Promise((resolve, reject) =&gt; { multi.expireat(key, moment(lockKey.expires).unix()) .exec((err, reply) =&gt; { debug('reply:', reply); if (err !== null) { reject(err); } else { resolve(reply); } }); }); const lockedFields = []; results.slice(0, fields.length).forEach((r, index) =&gt; { if (r === 1) { lockedFields.push(fields[index]); } }); debug('locked fields:', lockedFields); const lockedAll = lockedFields.length === fields.length; debug('lockedAll?', lockedAll); if (!lockedAll) { if (lockedFields.length &gt; 0) { // 全て仮押さえできなければ仮押さえできたものは解除 yield new Promise((resolve, reject) =&gt; { this.redisClient.multi() .hdel(key, lockedFields) .exec((err, reply) =&gt; { debug('reply:', reply); if (err !== null) { reject(err); } else { resolve(); } }); }); } throw new factory.errors.AlreadyInUse('', [], 'Seat number already hold'); } }); } /** * 座席ロックを解除する */ unlock(params) { return __awaiter(this, void 0, void 0, function* () { const key = `${RedisRepository.KEY_PREFIX}:${params.eventId}`; const field = `${params.offer.seatSection}:${params.offer.seatNumber}`; yield new Promise((resolve, reject) =&gt; { this.redisClient.multi() .hdel(key, field) .exec((err, reply) =&gt; { debug('reply:', reply); if (err !== null) { reject(err); } else { resolve(); } }); }); }); } /** * 空席でない座席を検索する */ findUnavailableOffersByEventId(params) { return __awaiter(this, void 0, void 0, function* () { const key = `${RedisRepository.KEY_PREFIX}:${params.eventId}`; return new Promise((resolve, reject) =&gt; { this.redisClient.hgetall(key, (err, reply) =&gt; { debug('reply:', reply); if (err !== null) { reject(err); } else { let offers = []; if (reply !== null) { offers = Object.keys(reply).map((field) =&gt; { const seatSection = field.split(':')[0]; const seatNumber = field.split(':')[1]; return { seatSection, seatNumber }; }); } resolve(offers); } }); }); }); } /** * 保持者を取得する */ getHolder(params) { return __awaiter(this, void 0, void 0, function* () { return new Promise((resolve, reject) =&gt; { const key = `${RedisRepository.KEY_PREFIX}:${params.eventId}`; const field = `${params.offer.seatSection}:${params.offer.seatNumber}`; this.redisClient.hget(key, field, (err, result) =&gt; { debug('result:', err, result); if (err !== null) { reject(err); } else { // tslint:disable-next-line:no-magic-numbers resolve(result); } }); }); }); } } RedisRepository.KEY_PREFIX = 'chevre:itemAvailability:screeningEvent'; exports.RedisRepository = RedisRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_reservationNumber.js.html":{"id":"repo_reservationNumber.js.html","title":"Source: repo/reservationNumber.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/reservationNumber.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const createDebug = require(&quot;debug&quot;); const moment = require(&quot;moment-timezone&quot;); const util = require(&quot;util&quot;); const factory = require(&quot;../factory&quot;); const debug = createDebug('chevre-domain:repo'); /** * Redisリポジトリー */ class RedisRepository { constructor(redisClient) { this.redisClient = redisClient; } /** * 発行する */ publish(params) { return __awaiter(this, void 0, void 0, function* () { return new Promise((resolve, reject) =&gt; { // 番号接頭辞は日付と販売者枝番号 const prefix = util.format('%s-%s', // tslint:disable-next-line:no-magic-numbers params.sellerBranchCode, moment(params.reserveDate).tz('Asia/Tokyo').format('YYMMDD')); const now = moment(); // 一日ごとにカウントアップするので、データ保管期間は一日あれば十分 const TTL = moment(now).add(1, 'day').diff(now, 'seconds'); debug(`TTL:${TTL} seconds`); const key = util.format('%s:%s', RedisRepository.REDIS_KEY_PREFIX, prefix); this.redisClient.multi() .incr(key, debug) .expire(key, TTL) .exec((err, results) =&gt; { debug('results:', results); // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore if: please write tests */ if (err instanceof Error) { reject(err); } else { // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore else: please write tests */ if (Number.isInteger(results[0])) { const no = results[0]; debug('no incremented.', no); resolve(util.format('%s-%s', prefix, // tslint:disable-next-line:no-magic-numbers (`000000${no}`).slice(-6) // 一販売者につき一日あたり最大1000000件以内の予約想定 )); } else { // 基本的にありえないフロー reject(new factory.errors.ServiceUnavailable('Reservation number not published')); } } }); }); }); } } RedisRepository.REDIS_KEY_PREFIX = 'chevre:reservationNumber'; exports.RedisRepository = RedisRepository; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_creativeWork.js.html":{"id":"repo_mongoose_model_creativeWork.js.html","title":"Source: repo/mongoose/model/creativeWork.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/creativeWork.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; const copyrightHolderSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); /** * 作品スキーマ */ const schema = new mongoose.Schema({ typeOf: { type: String, required: true }, identifier: String, name: String, description: String, copyrightHolder: copyrightHolderSchema, copyrightYear: Number, datePublished: Date, license: String, thumbnailUrl: String, duration: String, contentRating: String, subtitle: String, scheduleEndDate: Date, distribution: String }, { collection: 'creativeWorks', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); exports.default = mongoose.model('CreativeWork', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_priceSpecification.js.html":{"id":"repo_mongoose_model_priceSpecification.js.html","title":"Source: repo/mongoose/model/priceSpecification.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/priceSpecification.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; const eligibleQuantitySchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const eligibleTransactionVolumeSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const referenceQuantitySchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const priceComponentSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); /** * 価格仕様スキーマ */ const schema = new mongoose.Schema({ typeOf: { type: String, required: true }, eligibleQuantity: eligibleQuantitySchema, eligibleTransactionVolume: [eligibleTransactionVolumeSchema], maxPrice: Number, minPrice: Number, price: Number, priceCurrency: String, validFrom: Date, validThrough: Date, valueAddedTaxIncluded: Boolean, referenceQuantity: referenceQuantitySchema, appliesToSoundFormat: String, appliesToVideoFormat: String, priceComponent: [priceComponentSchema] }, { collection: 'priceSpecifications', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); schema.index({ typeOf: 1 }, { name: 'searchByTypeOf' }); schema.index({ 'priceComponent.typeOf': 1 }, { name: 'searchByPriceComponentTypeOf', partialFilterExpression: { 'priceComponent.typeOf': { $exists: true } } }); exports.default = mongoose.model('PriceSpecification', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_place.js.html":{"id":"repo_mongoose_model_place.js.html","title":"Source: repo/mongoose/model/place.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/place.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const multilingualString_1 = require(&quot;../schemaTypes/multilingualString&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; const containedInPlaceSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const containsPlaceSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const openingHoursSpecificationSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); /** * 場所スキーマ */ const schema = new mongoose.Schema({ _id: String, typeOf: { type: String, required: true }, name: multilingualString_1.default, description: multilingualString_1.default, address: multilingualString_1.default, branchCode: String, containedInPlace: containedInPlaceSchema, containsPlace: [containsPlaceSchema], maximumAttendeeCapacity: Number, openingHoursSpecification: openingHoursSpecificationSchema, smokingAllowed: Boolean, telephone: String, sameAs: String, url: String, kanaName: String }, { collection: 'places', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); // 劇場検索に使用 schema.index({ branchCode: 1, typeOf: 1 }); exports.default = mongoose.model('Place', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_action.js.html":{"id":"repo_mongoose_model_action.js.html","title":"Source: repo/mongoose/model/action.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/action.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; const agentSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const recipientSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const resultSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const errorSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const objectSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const purposeSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const locationSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const potentialActionsSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); /** * アクションスキーマ */ const schema = new mongoose.Schema({ actionStatus: String, typeOf: String, description: String, agent: agentSchema, recipient: recipientSchema, result: resultSchema, error: errorSchema, object: objectSchema, startDate: Date, endDate: Date, purpose: purposeSchema, potentialActions: potentialActionsSchema, amount: Number, fromLocation: locationSchema, toLocation: locationSchema }, { collection: 'actions', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); schema.index({ typeOf: 1, _id: 1 }); schema.index({ 'fromLocation.accountNumber': 1, typeOf: 1 }, { partialFilterExpression: { 'fromLocation.accountNumber': { $exists: true } } }); schema.index({ 'toLocation.accountNumber': 1, typeOf: 1 }, { partialFilterExpression: { 'toLocation.accountNumber': { $exists: true } } }); schema.index({ 'purpose.typeOf': 1 }, { partialFilterExpression: { 'purpose.typeOf': { $exists: true } } }); schema.index({ typeOf: 1, startDate: 1, endDate: 1, actionStatus: 1 }, { name: 'searchActions' }); exports.default = mongoose.model('Action', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_distributions.js.html":{"id":"repo_mongoose_model_distributions.js.html","title":"Source: repo/mongoose/model/distributions.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/distributions.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; /** * 配給スキーマ */ const schema = new mongoose.Schema({ _id: String, name: String }, { collection: 'distributions', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); exports.default = mongoose.model('Distributions', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_reservation.js.html":{"id":"repo_mongoose_model_reservation.js.html","title":"Source: repo/mongoose/model/reservation.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/reservation.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; const bookingAgentSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const reservationForSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const reservedTicketSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const underNameSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); /** * 予約スキーマ */ const schema = new mongoose.Schema({ _id: String, typeOf: { type: String, required: true }, additionalTicketText: String, bookingAgent: bookingAgentSchema, bookingTime: Date, cancelReservationUrl: String, checkinUrl: String, confirmReservationUrl: String, modifiedTime: Date, modifyReservationUrl: String, numSeats: Number, price: Number, priceCurrency: String, programMembershipUsed: String, reservationFor: reservationForSchema, reservationNumber: { type: String, required: true }, reservationStatus: { type: String, required: true }, reservedTicket: reservedTicketSchema, underName: underNameSchema, checkedIn: { type: Boolean, default: false }, attended: { type: Boolean, default: false } }, { collection: 'reservations', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); schema.index({ typeOf: 1 }, { name: 'searchByTypeOf' }); schema.index({ reservationNumber: 1 }, { name: 'searchByReservationNumber' }); schema.index({ reservationStatus: 1 }, { name: 'searchByReservationStatus' }); schema.index({ checkedIn: 1 }, { name: 'searchByCheckedIn' }); schema.index({ attended: 1 }, { name: 'searchByAttended' }); exports.default = mongoose.model('Reservation', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_transaction.js.html":{"id":"repo_mongoose_model_transaction.js.html","title":"Source: repo/mongoose/model/transaction.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/transaction.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; const objectSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const resultSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const agentSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const recipientSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const errorSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const potentialActionsSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); /** * 取引スキーマ */ const schema = new mongoose.Schema({ status: String, typeOf: String, agent: agentSchema, recipient: recipientSchema, error: errorSchema, result: resultSchema, object: objectSchema, expires: Date, startDate: Date, endDate: Date, tasksExportedAt: Date, tasksExportationStatus: String, potentialActions: potentialActionsSchema }, { collection: 'transactions', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); // タスクエクスポート時の検索で使用 schema.index({ tasksExportationStatus: 1, status: 1 }); // 取引期限切れ確認等に使用 schema.index({ status: 1, expires: 1 }); // 実行中タスクエクスポート監視に使用 schema.index({ tasksExportationStatus: 1, updatedAt: 1 }); // 取引進行中は、基本的にIDとステータスで参照する schema.index({ status: 1, typeOf: 1, _id: 1 }); // 許可証でユニークに schema.index({ 'object.passportToken': 1 }, { unique: true, partialFilterExpression: { 'object.passportToken': { $exists: true } } }); // 取引タイプ指定で取得する場合に使用 schema.index({ typeOf: 1, _id: 1 }); exports.default = mongoose.model('Transaction', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_ticketTypeGroup.js.html":{"id":"repo_mongoose_model_ticketTypeGroup.js.html","title":"Source: repo/mongoose/model/ticketTypeGroup.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/ticketTypeGroup.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const multilingualString_1 = require(&quot;../schemaTypes/multilingualString&quot;); const boxOfficeType_1 = require(&quot;./boxOfficeType&quot;); const ticketType_1 = require(&quot;./ticketType&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; /** * 券種グループスキーマ */ const schema = new mongoose.Schema({ _id: String, name: multilingualString_1.default, description: multilingualString_1.default, notes: multilingualString_1.default, ticketTypes: [{ type: String, ref: ticketType_1.default.modelName, required: true }], boxOfficeType: { type: String, ref: boxOfficeType_1.default.modelName, required: true } }, { collection: 'ticketTypeGroups', id: true, read: 'primaryPreferred', safe: safe, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); exports.default = mongoose.model('TicketTypeGroup', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_ticketType.js.html":{"id":"repo_mongoose_model_ticketType.js.html","title":"Source: repo/mongoose/model/ticketType.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/ticketType.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const multilingualString_1 = require(&quot;../schemaTypes/multilingualString&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; /** * 券種スキーマ */ const schema = new mongoose.Schema({ _id: String, name: multilingualString_1.default, description: multilingualString_1.default, notes: multilingualString_1.default, price: Number, availability: String, isBoxTicket: Boolean, isOnlineTicket: Boolean, nameForManagementSite: String, nameForPrinting: String, seatReservationUnit: Number, typeOfNote: Number, subject: String, nonBoxOfficeSubject: String, indicatorColor: String }, { collection: 'ticketTypes', id: true, read: 'primaryPreferred', safe: safe, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); exports.default = mongoose.model('TicketType', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_boxOfficeType.js.html":{"id":"repo_mongoose_model_boxOfficeType.js.html","title":"Source: repo/mongoose/model/boxOfficeType.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/boxOfficeType.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; /** * 興行区分スキーマ */ const schema = new mongoose.Schema({ _id: String, name: String }, { collection: 'boxOfficeTypes', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); exports.default = mongoose.model('BoxOfficeType', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_subject.js.html":{"id":"repo_mongoose_model_subject.js.html","title":"Source: repo/mongoose/model/subject.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/subject.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; /** * 科目スキーマ */ const schema = new mongoose.Schema({ subjectClassificationCd: String, subjectClassificationName: String, subjectCd: String, subjectName: String, detailCd: { type: String, unique: true }, detailName: String }, { collection: 'subjects', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); exports.default = mongoose.model('Subject', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_task.js.html":{"id":"repo_mongoose_model_task.js.html","title":"Source: repo/mongoose/model/task.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/task.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; const executionResultSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const dataSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); /** * タスクスキーマ */ const schema = new mongoose.Schema({ name: String, status: String, runsAt: Date, remainingNumberOfTries: Number, lastTriedAt: Date, numberOfTried: Number, executionResults: [executionResultSchema], data: dataSchema }, { collection: 'tasks', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); // 取引のタスク検索に使用 schema.index({ 'data.transactionId': 1 }, { partialFilterExpression: { 'data.transactionId': { $exists: true } } }); // 基本的にグループごとに、ステータスと実行日時を見て、タスクは実行される schema.index({ name: 1, status: 1, numberOfTried: 1, runsAt: 1 }); // ステータス&amp;最終トライ日時&amp;残りトライ可能回数を見て、リトライor中止を決定する schema.index({ remainingNumberOfTries: 1, status: 1, lastTriedAt: 1 }); // 測定データ作成時に使用 schema.index({ createdAt: 1, lastTriedAt: 1 }); schema.index({ status: 1, createdAt: 1 }); schema.index({ createdAt: 1 }); exports.default = mongoose.model('Task', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"repo_mongoose_model_event.js.html":{"id":"repo_mongoose_model_event.js.html","title":"Source: repo/mongoose/model/event.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: repo/mongoose/model/event.js &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const mongoose = require(&quot;mongoose&quot;); const multilingualString_1 = require(&quot;../schemaTypes/multilingualString&quot;); const safe = { j: true, w: 'majority', wtimeout: 10000 }; const locationSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const workPerformedSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const superEventSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const videoFormatSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const soundFormatSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); const offersSchema = new mongoose.Schema({}, { id: false, _id: false, strict: false }); /** * イベント(公演など)スキーマ */ const schema = new mongoose.Schema({ _id: String, typeOf: { type: String, required: true }, identifier: String, name: multilingualString_1.default, description: multilingualString_1.default, doorTime: Date, duration: String, endDate: Date, eventStatus: String, location: locationSchema, startDate: Date, workPerformed: workPerformedSchema, superEvent: superEventSchema, videoFormat: [videoFormatSchema], soundFormat: [soundFormatSchema], subtitleLanguage: Number, kanaName: String, alternativeHeadline: String, ticketTypeGroup: String, offers: offersSchema, maximumAttendeeCapacity: { type: Number, default: 0 }, remainingAttendeeCapacity: { type: Number, default: 0 }, checkInCount: { type: Number, default: 0 }, attendeeCount: { type: Number, default: 0 }, movieSubtitleName: String, signageDisplayName: String, signageDislaySubtitleName: String, summaryStartDay: Number, mvtkFlg: Number, saleStartDate: Date, onlineDisplayStartDate: Date, maxSeatNumber: Number, preSaleFlg: Number, endSaleTimeAfterScreening: Number, mvtkExcludeFlg: Number }, { collection: 'events', id: true, read: 'primaryPreferred', safe: safe, strict: true, useNestedStrict: true, timestamps: { createdAt: 'createdAt', updatedAt: 'updatedAt' }, toJSON: { getters: true }, toObject: { getters: true } }); // 上映イベント検索に使用 schema.index({ typeOf: 1, 'superEvent.location.branchCode': 1 }, { partialFilterExpression: { 'superEvent.location.branchCode': { $exists: true } }, name: 'searchScreeningEventsByLocationBranchCode' }); schema.index({ typeOf: 1, 'superEvent.workPerformed.identifier': 1, startDate: 1 }, { partialFilterExpression: { 'superEvent.workPerformed.identifier': { $exists: true } }, name: 'searchScreeningEventsByWorkPerformedIdentifier' }); schema.index({ typeOf: 1, startDate: 1 }); schema.index({ typeOf: 1, endDate: 1 }); schema.index({ 'offers.availabilityEnds': 1 }, { partialFilterExpression: { 'offers.availabilityEnds': { $exists: true } }, name: 'searchByOffersAvailabilityEnds' }); schema.index({ 'offers.availabilityStarts': 1 }, { partialFilterExpression: { 'offers.availabilityStarts': { $exists: true } }, name: 'searchByOffersAvailabilityStarts' }); schema.index({ 'offers.validThrough': 1 }, { partialFilterExpression: { 'offers.validThrough': { $exists: true } }, name: 'searchByOffersValidThrough' }); schema.index({ 'offers.validFrom': 1 }, { partialFilterExpression: { 'offers.validFrom': { $exists: true } }, name: 'searchByOffersValidFrom' }); exports.default = mongoose.model('Event', schema).on('index', // tslint:disable-next-line:no-single-line-block-comment /* istanbul ignore next */ (error) =&gt; { if (error !== undefined) { // tslint:disable-next-line:no-console console.error(error); } }); × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"service_offer.js.html":{"id":"service_offer.js.html","title":"Source: service/offer.js","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Source: service/offer.js &quot;use strict&quot;; var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); const reserve_api_abstract_client_1 = require(&quot;@movieticket/reserve-api-abstract-client&quot;); const moment = require(&quot;moment&quot;); const factory = require(&quot;../factory&quot;); const DEFAULT_ELIGIBLE_QUANTITY_VALUE = 4; /** * 上映イベントに対する券種オファーを検索する */ function searchScreeningEventTicketOffers(params) { // tslint:disable-next-line:max-func-body-length return (repos) =&gt; __awaiter(this, void 0, void 0, function* () { const event = yield repos.event.findById({ typeOf: factory.eventType.ScreeningEvent, id: params.eventId }); const eventSoundFormatTypes = (Array.isArray(event.superEvent.soundFormat)) ? event.superEvent.soundFormat.map((f) =&gt; f.typeOf) : []; const eventVideoFormatTypes = (Array.isArray(event.superEvent.videoFormat)) ? event.superEvent.videoFormat.map((f) =&gt; f.typeOf) : [factory.videoFormatType['2D']]; const ticketTypes = yield repos.ticketType.findByTicketGroupId({ ticketGroupId: event.ticketTypeGroup }); // 価格仕様を検索する const soundFormatCompoundPriceSpecifications = yield repos.priceSpecification.searchCompoundPriceSpecifications({ typeOf: factory.priceSpecificationType.CompoundPriceSpecification, priceComponent: { typeOf: factory.priceSpecificationType.SoundFormatChargeSpecification } }); const videoFormatCompoundPriceSpecifications = yield repos.priceSpecification.searchCompoundPriceSpecifications({ typeOf: factory.priceSpecificationType.CompoundPriceSpecification, priceComponent: { typeOf: factory.priceSpecificationType.VideoFormatChargeSpecification } }); const movieTicketTypeCompoundPriceSpecifications = yield repos.priceSpecification.searchCompoundPriceSpecifications({ typeOf: factory.priceSpecificationType.CompoundPriceSpecification, priceComponent: { typeOf: factory.priceSpecificationType.MovieTicketTypeChargeSpecification } }); const soundFormatChargeSpecifications = soundFormatCompoundPriceSpecifications.reduce((a, b) =&gt; [...a, ...b.priceComponent], []).filter((spec) =&gt; eventSoundFormatTypes.indexOf(spec.appliesToSoundFormat) &gt;= 0); const videoFormatChargeSpecifications = videoFormatCompoundPriceSpecifications.reduce((a, b) =&gt; [...a, ...b.priceComponent], []).filter((spec) =&gt; eventVideoFormatTypes.indexOf(spec.appliesToVideoFormat) &gt;= 0); const movieTicketTypeChargeSpecs = movieTicketTypeCompoundPriceSpecifications.reduce((a, b) =&gt; [...a, ...b.priceComponent], []).filter((spec) =&gt; eventVideoFormatTypes.indexOf(spec.appliesToVideoFormat) &gt;= 0); // Defaultオファーをセット let offers = { typeOf: 'Offer', priceCurrency: factory.priceCurrency.JPY, availabilityEnds: moment(event.endDate).toDate(), availabilityStarts: moment(event.endDate).toDate(), validFrom: moment(event.endDate).toDate(), validThrough: moment(event.endDate).toDate(), eligibleQuantity: { value: DEFAULT_ELIGIBLE_QUANTITY_VALUE, unitCode: factory.unitCode.C62, typeOf: 'QuantitativeValue' } }; // オファー設定があれば上書きする if (event.offers !== undefined &amp;&amp; event.offers !== null) { offers = event.offers; } // ムビチケが決済方法として許可されていれば、ムビチケ券種区分ごとにムビチケオファーを作成 const movieTicketOffers = []; const movieTicketPaymentAccepted = event.superEvent.offers === undefined || event.superEvent.offers.acceptedPaymentMethod === undefined || event.superEvent.offers.acceptedPaymentMethod.indexOf(factory.paymentMethodType.MovieTicket) &gt;= 0; if (movieTicketPaymentAccepted) { const movieTicketTypeCodes = [...new Set(movieTicketTypeChargeSpecs.map((s) =&gt; s.appliesToMovieTicketType))]; movieTicketOffers.push(...movieTicketTypeCodes.map((movieTicketTypeCode) =&gt; { const movieTicketType = reserve_api_abstract_client_1.mvtk.util.constants.TICKET_TYPE.find((ticketType) =&gt; ticketType.code === movieTicketTypeCode); const unitPriceSpecification = { typeOf: factory.priceSpecificationType.UnitPriceSpecification, price: 0, priceCurrency: factory.priceCurrency.JPY, name: { ja: `ムビチケ${(movieTicketType !== undefined) ? movieTicketType.name : ''}`, en: 'Movie Ticket', kr: 'Movie Ticket' }, description: { ja: `ムビチケ${(movieTicketType !== undefined) ? movieTicketType.name : ''}`, en: 'Movie Ticket', kr: 'Movie Ticket' }, valueAddedTaxIncluded: true, referenceQuantity: { typeOf: 'QuantitativeValue', unitCode: factory.unitCode.C62, value: 1 } }; const mvtkSpecs = movieTicketTypeChargeSpecs.filter((s) =&gt; s.appliesToMovieTicketType === movieTicketTypeCode); const priceComponent = [ unitPriceSpecification, ...mvtkSpecs ]; const compoundPriceSpecification = { typeOf: factory.priceSpecificationType.CompoundPriceSpecification, priceCurrency: factory.priceCurrency.JPY, valueAddedTaxIncluded: true, priceComponent: priceComponent }; return { typeOf: 'Offer', id: `Offer-by-movieticket-${movieTicketTypeCode}`, name: { ja: `ムビチケ${(movieTicketType !== undefined) ? movieTicketType.name : ''}`, en: 'Movie Ticket', kr: 'Movie Ticket' }, description: { ja: `ムビチケ${(movieTicketType !== undefined) ? movieTicketType.name : ''}`, en: 'Movie Ticket', kr: 'Movie Ticket' }, valueAddedTaxIncluded: true, priceCurrency: factory.priceCurrency.JPY, priceSpecification: compoundPriceSpecification, availability: factory.itemAvailability.InStock, availabilityEnds: offers.availabilityEnds, availabilityStarts: offers.availabilityStarts, eligibleQuantity: offers.eligibleQuantity, validFrom: offers.validFrom, validThrough: offers.validThrough }; })); } const ticketTypeOffers = ticketTypes.map((ticketType) =&gt; { // イベントに関係のある価格仕様に絞り、ひとつの複合価格仕様としてまとめる const unitPriceSpecification = { typeOf: factory.priceSpecificationType.UnitPriceSpecification, price: ticketType.price, priceCurrency: factory.priceCurrency.JPY, name: ticketType.name, description: ticketType.description, valueAddedTaxIncluded: true, referenceQuantity: { typeOf: 'QuantitativeValue', unitCode: factory.unitCode.C62, value: 1 } }; const priceComponent = [ unitPriceSpecification, ...videoFormatChargeSpecifications, ...soundFormatChargeSpecifications ]; const compoundPriceSpecification = { typeOf: factory.priceSpecificationType.CompoundPriceSpecification, priceCurrency: factory.priceCurrency.JPY, valueAddedTaxIncluded: true, priceComponent: priceComponent }; return { typeOf: 'Offer', id: ticketType.id, name: ticketType.name, description: ticketType.description, priceCurrency: factory.priceCurrency.JPY, priceSpecification: compoundPriceSpecification, availability: ticketType.availability, availabilityEnds: offers.availabilityEnds, availabilityStarts: offers.availabilityStarts, eligibleQuantity: offers.eligibleQuantity, validFrom: offers.validFrom, validThrough: offers.validThrough }; }); return [...ticketTypeOffers, ...movieTicketOffers]; }); } exports.searchScreeningEventTicketOffers = searchScreeningEventTicketOffers; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Global Members &lt;constant&gt; action_1 リポジトリー Source: repository.js, line 7 &lt;constant&gt; AggregationService service module Source: service.js, line 6 &lt;constant&gt; createDebug 予約取引サービス Source: service/transaction/reserve.js, line 14 &lt;constant&gt; createDebug 予約キャンセル取引サービス Source: service/transaction/cancelReservation.js, line 14 &lt;constant&gt; createDebug タスクサービス Source: service/task.js, line 14 &lt;constant&gt; createDebug 集計サービス Source: service/aggregation.js, line 14 &lt;constant&gt; createDebug 予約サービス Source: service/reserve.js, line 14 default 多言語文字列mongooseスキーマタイプ Source: repo/mongoose/schemaTypes/multilingualString.js, line 6 &lt;constant&gt; mongoose index module Source: index.js, line 6 mongoose MongoDBクライアントmongoose Source: index.js, line 18 Example const promise = domain.mongoose.connect('mongodb://localhost/myapp', { useMongoClient: true }); redis Redis Cacheクライアント Source: index.js, line 29 Example const client = domain.redis.createClient({ host: process.env.REDIS_HOST, port: process.env.REDIS_PORT, password: process.env.REDIS_KEY, tls: { servername: process.env.REDIS_HOST } }); &lt;constant&gt; schema 作品スキーマ Source: repo/mongoose/model/creativeWork.js, line 13 &lt;constant&gt; schema 価格仕様スキーマ Source: repo/mongoose/model/priceSpecification.js, line 28 &lt;constant&gt; schema 場所スキーマ Source: repo/mongoose/model/place.js, line 24 &lt;constant&gt; schema アクションスキーマ Source: repo/mongoose/model/action.js, line 48 &lt;constant&gt; schema 配給スキーマ Source: repo/mongoose/model/distributions.js, line 8 &lt;constant&gt; schema 予約スキーマ Source: repo/mongoose/model/reservation.js, line 28 &lt;constant&gt; schema 取引スキーマ Source: repo/mongoose/model/transaction.js, line 38 &lt;constant&gt; schema 券種グループスキーマ Source: repo/mongoose/model/ticketTypeGroup.js, line 11 &lt;constant&gt; schema 券種スキーマ Source: repo/mongoose/model/ticketType.js, line 9 &lt;constant&gt; schema 興行区分スキーマ Source: repo/mongoose/model/boxOfficeType.js, line 8 &lt;constant&gt; schema 科目スキーマ Source: repo/mongoose/model/subject.js, line 8 &lt;constant&gt; schema タスクスキーマ Source: repo/mongoose/model/task.js, line 18 &lt;constant&gt; schema イベント(公演など)スキーマ Source: repo/mongoose/model/event.js, line 39 &lt;constant&gt; sortOrder4executionOfTasks タスク実行時のソート条件 Source: repo/task.js, line 17 Methods abort(intervalInMinutes) abort a taskトライ可能回数が0に達したタスクを実行中止する Parameters: Name Type Description intervalInMinutes 最終トライ日時から何分経過したタスクを中止するか Source: service/task.js, line 88 aggregateScreeningEvent() 上映イベントデータをID指定で集計する Source: service/aggregation.js, line 74 call() タスク実行関数 Source: service/task/reserve.js, line 18 call() タスク実行関数 Source: service/task/aggregateScreeningEvent.js, line 18 call() タスク実行関数 Source: service/task/cancelReservation.js, line 21 call() タスク実行関数 Source: service/task/cancelPendingReservation.js, line 20 cancel() 取引中止 Source: service/transaction/reserve.js, line 209 cancelPendingReservation() 進行中の予約をキャンセルする Source: service/reserve.js, line 61 cancelReservation() 予約をキャンセルする Source: service/reserve.js, line 109 confirm() 取引確定 Source: service/transaction/reserve.js, line 162 confirm() 取引確定 Source: service/transaction/cancelReservation.js, line 62 confirmReservation() 予約を確定する Source: service/reserve.js, line 20 countTicketTypePerEvent() countTicketTypePerEvent Source: service/event.js, line 14 execute(task) execute a taskタスクを実行する Parameters: Name Type Description task タスクオブジェクト Source: service/task.js, line 46 executeByName(taskName) execute a task by taskNameタスク名でタスクをひとつ実行する Parameters: Name Type Description taskName タスク名 Source: service/task.js, line 23 exportTasks() ひとつの取引のタスクをエクスポートする Source: service/transaction/cancelReservation.js, line 102 exportTasks() ひとつの取引のタスクをエクスポートする Source: service/transaction/reserve.js, line 241 exportTasksById() ID指定で取引のタスク出力 Source: service/transaction/cancelReservation.js, line 120 exportTasksById() ID指定で取引のタスク出力 Source: service/transaction/reserve.js, line 259 retry(intervalInMinutes) retry tasks in running status実行中ステータスのままになっているタスクをリトライする Parameters: Name Type Description intervalInMinutes 最終トライ日時から何分経過したタスクをリトライするか Source: service/task.js, line 77 searchScreeningEventTicketOffers() 上映イベントに対する券種オファーを検索する Source: service/offer.js, line 18 start() 取引開始 Source: service/transaction/reserve.js, line 23 start() 取引開始 Source: service/transaction/cancelReservation.js, line 20 × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Classes Classes MongoRepository MongoRepository MongoRepository MongoRepository MongoRepository MongoRepository MongoRepository MongoRepository MongoRepository MongoRepository MongoRepository MongoRepository RedisRepository RedisRepository RedisRepository Repository Repository × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Chevre Domain Library for Node.js Chevre座席予約システムのドメインモデルをNode.jsで使いやすいようにまとめたパッケージです。 Table of contents Usage Code Samples License Usagenpm install --save @toei-jp/chevre-domainconst chevre = require(&quot;@toei-jp/chevre-domain&quot;);前提として、mongooseでdefault connectionを確保することと、redis情報をセットすることが必要。 mongoose default connection chevre.mongoose.connect();Environment variables Name Required Value Purpose DEBUG false chevre-domain:* Debug Code SamplesCode sample are here. LicenseISC × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"MongoRepository.html":{"id":"MongoRepository.html","title":"Class: MongoRepository","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Class: MongoRepository MongoRepository 作品リポジトリー new MongoRepository() Source: repo/creativeWork.js, line 22 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 Class: MongoRepository MongoRepository イベントリポジトリー new MongoRepository() Source: repo/event.js, line 17 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 Class: MongoRepository MongoRepository 配給レポジトリー new MongoRepository() Source: repo/distributions.js, line 16 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 Class: MongoRepository MongoRepository 取引リポジトリー new MongoRepository() Source: repo/transaction.js, line 17 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 Class: MongoRepository MongoRepository Mongoリポジトリー new MongoRepository() Source: repo/ticketType.js, line 17 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 Class: MongoRepository MongoRepository タスクレポジトリー new MongoRepository() Source: repo/task.js, line 24 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 Class: MongoRepository MongoRepository 科目レポジトリー new MongoRepository() Source: repo/subject.js, line 17 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 Class: MongoRepository MongoRepository 場所リポジトリー new MongoRepository() Source: repo/place.js, line 22 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 Class: MongoRepository MongoRepository 興行区分レポジトリー new MongoRepository() Source: repo/boxOfficeType.js, line 16 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 Class: MongoRepository MongoRepository 予約リポジトリー new MongoRepository() Source: repo/reservation.js, line 16 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 Class: MongoRepository MongoRepository 価格仕様リポジトリー new MongoRepository() Source: repo/priceSpecification.js, line 15 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 Class: MongoRepository MongoRepository アクションリポジトリー new MongoRepository() Source: repo/action.js, line 16 Methods attend() 入場する Source: repo/reservation.js, line 184 cancel() 予約取消 Source: repo/reservation.js, line 154 cancel() 取引を中止する Source: repo/transaction.js, line 225 cancel() アクション取消 Source: repo/action.js, line 50 checkIn() 発券する Source: repo/reservation.js, line 169 complete() アクション完了 Source: repo/action.js, line 31 confirm() 取引を確定する Source: repo/transaction.js, line 136 confirm() 予約確定 Source: repo/reservation.js, line 142 createBoxOfficeType() 興行区分を作成する Source: repo/boxOfficeType.js, line 50 createDistribution() 配給を作成する Source: repo/distributions.js, line 50 createTicketType() 券種を作成する Source: repo/ticketType.js, line 183 createTicketTypeGroup() 券種グループを作成する Source: repo/ticketType.js, line 106 deleteById() IDで興行区分を削除する Source: repo/boxOfficeType.js, line 112 deleteById() IDで配給を削除する Source: repo/distributions.js, line 112 deleteById() IDでイベントを削除する Source: repo/event.js, line 402 deleteMovie() 映画作品を削除する Source: repo/creativeWork.js, line 119 deleteTicketType() 券種を削除する Source: repo/ticketType.js, line 250 deleteTicketTypeGroup() 券種グループを削除する Source: repo/ticketType.js, line 173 findById() IDでイベントを取得する Source: repo/event.js, line 383 findById() IDで取引を取得する Source: repo/transaction.js, line 105 findById() IDで配給を取得する Source: repo/distributions.js, line 94 findById() IDで興行区分を取得する Source: repo/boxOfficeType.js, line 94 findById() IDで取得する Source: repo/action.js, line 84 findInProgressById() 進行中の取引を取得する Source: repo/transaction.js, line 120 findMovieByIdentifier() IDで映画作品を検索する Source: repo/creativeWork.js, line 69 findMovieTheaterByBranchCode() 枝番号で劇場検索 Source: repo/place.js, line 93 findScreeningEventReservationById() IDで上映イベント予約を検索する Source: repo/reservation.js, line 126 findSubjectById() IDで科目を検索する Source: repo/subject.js, line 61 findTicketTypeById() IDで件券種を検索する Source: repo/ticketType.js, line 192 findTicketTypeGroupById() IDで件券種グループを検索する Source: repo/ticketType.js, line 115 findTicketTypeGroupByTicketTypeId() 関連券種グループリスト Source: repo/ticketType.js, line 260 giveUp() アクション失敗 Source: repo/action.js, line 65 makeExpired() 取引を期限切れにする Source: repo/transaction.js, line 209 reexportTasks() タスクエクスポートリトライtodo updatedAtを基準にしているが、タスクエクスポートトライ日時を持たせた方が安全か？ Source: repo/transaction.js, line 184 save() 科目を保管する Source: repo/subject.js, line 32 saveMovie() 映画作品を保管する Source: repo/creativeWork.js, line 58 saveMovieTheater() 劇場を保管する Source: repo/place.js, line 49 saveMultipleScreeningEvent() 複数の上映イベントを保管する Source: repo/event.js, line 311 saveScreeningEvent() 上映イベントを保管する Source: repo/event.js, line 287 saveScreeningEventSeries() 上映イベントを保管する Source: repo/event.js, line 263 search() 取引を検索する Source: repo/transaction.js, line 267 searchBoxOfficeType() 興行区分を検索する Source: repo/boxOfficeType.js, line 75 searchDistributions() 配給を検索する Source: repo/distributions.js, line 75 searchMovies() 映画作品を検索する Source: repo/creativeWork.js, line 95 searchMovieTheaters() 劇場検索 Source: repo/place.js, line 67 searchScreeningEventReservations() 上映イベント予約を検索する Source: repo/reservation.js, line 102 searchScreeningEvents() 上映イベントを検索する Source: repo/event.js, line 328 searchScreeningEventSeries() 上映イベントシリーズを検索する Source: repo/event.js, line 359 searchSubject() 科目を検索する Source: repo/subject.js, line 79 searchTicketTypeGroups() 券種グループを検索する Source: repo/ticketType.js, line 140 searchTicketTypes() 券種を検索する Source: repo/ticketType.js, line 217 setTasksExportedById() set task status exported by transaction idIDでタスクをエクスポート済に変更する Source: repo/transaction.js, line 198 start() アクション開始 Source: repo/action.js, line 23 start() 取引を開始する Source: repo/transaction.js, line 97 startExportTasks() タスク未エクスポートの取引をひとつ取得してエクスポートを開始する Source: repo/transaction.js, line 171 updateBoxOfficeType() 興行区分を保管する Source: repo/boxOfficeType.js, line 38 updateDistribution() 配給を保管する Source: repo/distributions.js, line 38 updateTicketType() 券種を更新する Source: repo/ticketType.js, line 237 updateTicketTypeGroup() 券種グループを更新する Source: repo/ticketType.js, line 160 × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"RedisRepository.html":{"id":"RedisRepository.html","title":"Class: RedisRepository","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Class: RedisRepository RedisRepository 上映イベントに関する集計データを保管するリポジトリ new RedisRepository() Source: repo/aggregation/screeningEvent.js, line 14 Methods findUnavailableOffersByEventId() 空席でない座席を検索する Source: repo/itemAvailability/screeningEvent.js, line 102 getHolder() 保持者を取得する Source: repo/itemAvailability/screeningEvent.js, line 129 lock() 座席をロックする Source: repo/itemAvailability/screeningEvent.js, line 25 publish() 発行する Source: repo/reservationNumber.js, line 26 unlock() 座席ロックを解除する Source: repo/itemAvailability/screeningEvent.js, line 80 Class: RedisRepository RedisRepository 上映イベントに対する座席ごとの在庫状況を保管するリポジトリ new RedisRepository() Source: repo/itemAvailability/screeningEvent.js, line 18 Methods findUnavailableOffersByEventId() 空席でない座席を検索する Source: repo/itemAvailability/screeningEvent.js, line 102 getHolder() 保持者を取得する Source: repo/itemAvailability/screeningEvent.js, line 129 lock() 座席をロックする Source: repo/itemAvailability/screeningEvent.js, line 25 publish() 発行する Source: repo/reservationNumber.js, line 26 unlock() 座席ロックを解除する Source: repo/itemAvailability/screeningEvent.js, line 80 Class: RedisRepository RedisRepository Redisリポジトリー new RedisRepository() Source: repo/reservationNumber.js, line 19 Methods findUnavailableOffersByEventId() 空席でない座席を検索する Source: repo/itemAvailability/screeningEvent.js, line 102 getHolder() 保持者を取得する Source: repo/itemAvailability/screeningEvent.js, line 129 lock() 座席をロックする Source: repo/itemAvailability/screeningEvent.js, line 25 publish() 発行する Source: repo/reservationNumber.js, line 26 unlock() 座席ロックを解除する Source: repo/itemAvailability/screeningEvent.js, line 80 × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "},"Repository.html":{"id":"Repository.html","title":"Class: Repository","body":" Chevre Domain Library for Node.js Classes MongoRepositoryRedisRepositoryRepository Global abortaction_1aggregateScreeningEventAggregationServicecallcancelcancelPendingReservationcancelReservationconfirmconfirmReservationcountTicketTypePerEventcreateDebugdefaultexecuteexecuteByNameexportTasksexportTasksByIdmongooseredisretryschemasearchScreeningEventTicketOfferssortOrder4executionOfTasksstart Class: Repository Repository 作品抽象リポジトリー new Repository() Source: repo/creativeWork.js, line 16 Class: Repository Repository 場所抽象リポジトリー new Repository() Source: repo/place.js, line 16 × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Oct 31st 2018 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
